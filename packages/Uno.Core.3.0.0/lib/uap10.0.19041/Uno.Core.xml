<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Uno.Core</name>
    </assembly>
    <members>
        <member name="F:Uno.Actions.Null">
            <summary>
            An action which does nothing.
            </summary>
        </member>
        <member name="F:Uno.Actions.NullAsync">
            <summary>
            An ActionAsync which does nothing.
            </summary>
        </member>
        <member name="M:Uno.Actions.CreateOnce(System.Action)">
            <summary>
            Creates an action that will only execute once the provided action, even if called multiple times. This is Thread Safe.
            </summary>
            <param name="action">The action to be executed once</param>
            <returns>An action.</returns>
        </member>
        <member name="T:Uno.Actions`1">
            <summary>
            Container for stock actions.
            </summary>
            <typeparam name="T">The type of the argument for the actions.</typeparam>
        </member>
        <member name="F:Uno.Actions`1.Null">
            <summary>
            A Null action, that performs nothing.
            </summary>
        </member>
        <member name="F:Uno.Actions`1.NullAsync">
            <summary>
            A Null action, that performs nothing.
            </summary>
        </member>
        <member name="F:Uno.Actions`2.Null">
            <summary>
            A Null action, that performs nothing.
            </summary>
        </member>
        <member name="F:Uno.Actions`2.NullAsync">
            <summary>
            A Null action, that performs nothing.
            </summary>
        </member>
        <member name="T:Uno.Extensions.CollectionExtensions">
            <summary>
            Provides Extensions Methods for ICollection.
            </summary>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.AddNew``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Adds a new item with the default constructor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds the items of the specified collection to the end of the ICollection.
            </summary>
            <typeparam name="T">The type of the items.</typeparam>
            <param name="collection">Collection in which to insert items.</param>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.DisposableAdd``1(System.Collections.Generic.ICollection{``0},``0)">
            <summary>
            Adds an item into the collection and returns an IDisposable which will remove the item when disposed.
            </summary>
            <typeparam name="T">Type of the items in collection</typeparam>
            <param name="collection"></param>
            <param name="item">The item to add</param>
            <returns>An IDisposable which will remove the item when disposed</returns>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.Remove``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.Boolean})">
            <summary>
            Removes items in a collection that are identified with a predicate.
            </summary>
            <typeparam name="T">the type of the items</typeparam>
            <param name="collection">Collection in which to remove items.</param>
            <param name="predicate">The predicate used to identify if a item is to be removed or not.</param>
            <returns>Count of removed items</returns>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.Adapt``2(System.Collections.Generic.ICollection{``0},System.Func{``1,``0},System.Func{``0,``1})">
            <summary>
            Adapts a collection of type T into a collection of type U
            </summary>
            <typeparam name="TSource">The type to adapt.</typeparam>
            <typeparam name="TTarget">The target type.</typeparam>
            <param name="collection">The collection to adapt</param>
            <param name="from">The function used to adapt a U into a T.</param>
            <param name="to">The function used to adapt a T into a U.</param>
            <returns>A adapted collection of the target type.</returns>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.ReplaceWith``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Replaces the items in a collection with a new set of items.
            </summary>
            <typeparam name="T">The type of items.</typeparam>
            <param name="collection">The collection who's content will be replaced.</param>
            <param name="items">The replacing items.</param>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.AddDistinct``1(System.Collections.Generic.ICollection{``0},``0)">
            <summary>
            Adds an item to a collection if not already in it.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="item">Item to add</param>
            <returns>True if the item was added, else false.</returns>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.AddDistinct``1(System.Collections.Generic.ICollection{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Adds an item to a collection if not already in it using an EqualityComparer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="item">Item to add</param>
            <param name="comparer">Equality comparer to use to determine if item is already in the collection</param>
            <returns>True if the item was added, else false.</returns>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.AddDistinct``1(System.Collections.Generic.ICollection{``0},``0,System.Func{``0,``0,System.Boolean})">
            <summary>
            Adds an item to a collection if not already in it using a predicate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="item">Item to add</param>
            <param name="predicate">Predicate to use to determine if item is already in the collection</param>
            <returns>True if the item was added, else false.</returns>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.AddRangeDistinct``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds to a collection the items of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> which are not already in collection.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="items">Items to add</param>
            <returns>Count of items added</returns>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.AddRangeDistinct``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Adds to a collection the items of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> which are not already in collection using an equlaity comparer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="items">Items to add</param>
            <param name="comparer">Equality comparer to use to determine if an item is already in the collection</param>
            <returns>Count of items added</returns>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.AddRangeDistinct``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            Adds to a collection the items of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> which are not already in collection using an equlaity comparer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="items">Items to add</param>
            <param name="comparer">Predicate to use to determine if an item is already in the collection</param>
            <returns>Count of items added</returns>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.SelectToArray``2(``0[],System.Func{``0,``1})">
            <summary>
            Projects the specified array to another array.
            </summary>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.SelectToArray``2(``0[],System.Func{``0,System.Int32,``1})">
            <summary>
            Projects the specified array to another array, using the item index.
            </summary>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.SelectToArray``2(System.Collections.Generic.ICollection{``0},System.Func{``0,``1})">
            <summary>
            Projects the specified collection to an array.
            </summary>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.ToRangeArray``1(``0[],System.Int32,System.Int32)">
            <summary>
            Create an array from a portion of another array, as a faster equivalent of .Skip().Take().ToArray().
            </summary>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.SelectToList``2(System.Collections.Generic.ICollection{``0},System.Func{``0,``1})">
            <summary>
            Projects the specified collection to a <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <remarks>This method can be useful when the enumeation of the result requires less allocations.(see <see cref="T:System.Collections.Generic.List`1.Enumerator"/>)</remarks>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.SelectToList``2(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
            <summary>
            Projects the specified collection to a <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <remarks>This method can be useful when the enumeation of the result requires less allocations.(see <see cref="T:System.Collections.Generic.List`1.Enumerator"/>)</remarks>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.SelectToList``2(System.Collections.Generic.List{``0},System.Func{``0,``1})">
            <summary>
            Projects a <see cref="T:System.Collections.Generic.List`1"/>. to an other <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <remarks>This method can be useful when the enumeation of the result requires less allocations.(see <see cref="T:System.Collections.Generic.List`1.Enumerator"/>)</remarks>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.SelectToList``2(System.Collections.Generic.List{``0},System.Func{``0,System.Int32,``1})">
            <summary>
            Projects the specified <see cref="T:System.Collections.Generic.List`1"/> to an other <see cref="T:System.Collections.Generic.List`1"/> with an index.
            </summary>
            <remarks>This method can be useful when the enumeation of the result requires less allocations.(see <see cref="T:System.Collections.Generic.List`1.Enumerator"/>)</remarks>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.WhereToList``1(System.Collections.Generic.List{``0},System.Func{``0,System.Boolean})">
            <summary>
            Filters the specified <see cref="T:System.Collections.Generic.List`1"/> using a predicate.
            </summary>
            <remarks>This method can be useful when the enumeation of the result requires less allocations.(see <see cref="T:System.Collections.Generic.List`1.Enumerator"/>)</remarks>
        </member>
        <member name="M:Uno.Extensions.CollectionExtensions.ToRangeList``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>
            Create a <see cref="T:System.Collections.Generic.List`1"/> from a portion of another <see cref="T:System.Collections.Generic.List`1"/>, as a faster equivalent of .Skip().Take().ToList().
            </summary>
            <remarks>This method can be useful when the enumeation of the result requires less allocations.(see <see cref="T:System.Collections.Generic.List`1.Enumerator"/>)</remarks>
        </member>
        <member name="M:Uno.Extensions.DictionaryExtensions.UnoGetValueOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Gets the value associated with the specified key, or a default value.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dictionary"></param>
            <param name="key">The key of the value to get.</param>
            <param name="defaultValue">Default value if the key does not exsists in dictionary</param>
            <returns>the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter.</returns>
        </member>
        <member name="M:Uno.Extensions.DictionaryExtensions.UnoGetValueOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Gets the value associated with the specified key, or a default value.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dictionary"></param>
            <param name="key">The key of the value to get.</param>
            <param name="defaultValue">Default value if the key does not exsists in dictionary</param>
            <returns>the value associated with the specified key, if the key is found; otherwise, the <paramref name="defaultValue"/>.</returns>
        </member>
        <member name="T:Uno.Extensions.EnumerableExtensions">
            <summary>
            Provides Extensions Methods for IEnumerable.
            </summary>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.Concat``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Append an item at the end of an enumeration
            </summary>
            <remarks>
            Use .Prepend() to inject before the enumeration
            </remarks>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.PrependEx``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Add an item who will be enumerated first before the real enumeration
            </summary>
            <remarks>
            Use .Concat() to inject at the end of the enumeration
            </remarks>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.Except``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Exclude some items from an enumeration
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="items">Items to exclude</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0},``0[])">
            <summary>
            Exclude some items from an enumeration using an equality comparer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="equalityComparer">Equality comparer to use to compare items between enumerations</param>
            <param name="items">Items to exclude</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.AreDistinct``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Check if all element in the enumeration are disctinct.
            </summary>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.AreDistinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Check if all element in the enumeration are distinct.
            </summary>
            <typeparam name="T">Type of the items</typeparam>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Finds an item in the sequence for which a projected value is minimized.
            </summary>
            <typeparam name="TSource">Sequence type.</typeparam>
            <typeparam name="TComparable">Projected value type.</typeparam>
            <param name="source">The sequence of items.</param>
            <param name="selector">Function which projects the sequence into a comparable value.</param>
            <returns>A tuple containing the minimum item and its projected value. If multiple items have the same projected value, this will return the first.</returns>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Finds an item in the sequence for which a projected value is maximized.
            </summary>
            <typeparam name="TSource">Sequence type.</typeparam>
            <typeparam name="TComparable">Projected value type.</typeparam>
            <param name="source">The sequence of items.</param>
            <param name="selector">Function which projects the sequence into a comparable value.</param>
            <returns>A tuple containing the maximum item and its projected value. If multiple items have the same projected value, this will return the first.</returns>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.Range``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Takes "before" item and "after" item around the "start" item
            </summary>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.Do``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Intercept enumerated elements. SEE REMARKS FOR USAGE!
            </summary>
            <remarks>
            This method is not doing the enumeration,
            only intercept it when an enumeration occurs.
            </remarks>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.Trim``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Remove null values while enumerating
            </summary>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.Trim``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
            <summary>
            Remove null values while enumerating
            </summary>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.ToObservableCollection``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Create an ObservableCollection for an enumeration.
            </summary>
            <remarks>
            The copy is done synchronously, before this method returns.
            </remarks>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.Safe``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Prevent null enumeration.
            When null, it's replaced with an empty enumeration of the same type.
            </summary>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.StdDev(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Calculate a Standard Deviation over an enumerator of values.
            </summary>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.Flatten``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Enumerate the item first, followed by items of the predicate
            </summary>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.AllEquals``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Check if all items of an enumerable are equals, using an optional comparer
            </summary>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.AllTrue(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Determines whether all elements of a sequence are true.
            </summary>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.AllTrueOrDefault(System.Collections.Generic.IEnumerable{System.Boolean},System.Boolean)">
            <summary>
            Determines whether all elements of a sequence are true.
            </summary>
            <param name="defaultValue">Default value if source is null or empty</param>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.AnyTrue(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Determines whether any element of a sequence is true.
            </summary>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.AnyTrueOrDefault(System.Collections.Generic.IEnumerable{System.Boolean},System.Boolean)">
            <summary>
            Determines whether any element of a sequence satisfies a condition.
            </summary>
            <param name="defaultValue">Default value if source is null or empty</param>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.ConsecutiveValueCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Count number of consecutive equals values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.ToDictionaryDistinct``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.Dictionary`2"/> with unique keys from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to a specified key selector function, and an element selector function.
            </summary>
            <typeparam name="TSource">Type of the source enumerable</typeparam>
            <typeparam name="TKey">Type of the keys of the result dictionary</typeparam>
            <typeparam name="TValue">Type of the value of the result dictionary</typeparam>
            <param name="source">Source enuemrable</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="valueSelector">A transform function to produce a result element value from each element.</param>
            <returns>A <see cref="T:System.Collections.Generic.Dictionary`2"/> that contains values of type TElement selected from the input sequence.</returns>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.ToDictionaryDistinct``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.Dictionary`2"/> with unique keys from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to a specified key selector function, a comparer, and an element selector function.
            </summary>
            <typeparam name="TSource">Type of the source enumerable</typeparam>
            <typeparam name="TKey">Type of the keys of the result dictionary</typeparam>
            <typeparam name="TValue">Type of the value of the result dictionary</typeparam>
            <param name="source">Source enuemrable</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="valueSelector">A transform function to produce a result element value from each element.</param>
            <param name="equalityComparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A <see cref="T:System.Collections.Generic.Dictionary`2"/> that contains values of type TElement selected from the input sequence.</returns>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.ToDictionaryDistinct``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.Dictionary`2"/> with unique keys from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to a specified key selector function.
            </summary>
            <typeparam name="TSource">Type of the source enumerable and values of the result dictionary</typeparam>
            <typeparam name="TKey">Type of the keys of the result dictionary</typeparam>
            <param name="source">Source enuemrable</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <returns>A <see cref="T:System.Collections.Generic.Dictionary`2"/> that contains values of type TElement selected from the input sequence.</returns>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.ToDictionaryDistinct``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.Dictionary`2"/> with unique keys from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to a specified key selector function, and a comparer.
            </summary>
            <typeparam name="TSource">Type of the source enumerable and values of the result dictionary</typeparam>
            <typeparam name="TKey">Type of the keys of the result dictionary</typeparam>
            <param name="source">Source enuemrable</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="equalityComparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A <see cref="T:System.Collections.Generic.Dictionary`2"/> that contains values of type TElement selected from the input sequence.</returns>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.ToDictionary``2(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{``0,``1}})">
            <summary>
            Creates a Dictionary&lt;TKey,IEnumerable&lt;TSource&gt;&gt; from an IEnumerable&lt;IGrouping&lt;TSource&gt;&gt;;
            </summary>
            <typeparam name="TKey">Type of the keys of the result dictionary</typeparam>
            <typeparam name="TValue">Type of the value of the result dictionary</typeparam>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.ToDictionary``2(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{``0,``1}},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates a Dictionary&lt;TKey,IEnumerable&lt;TSource&gt;&gt; from an IEnumerable&lt;IGrouping&lt;TSource&gt;&gt;;
            </summary>
            <typeparam name="TKey">Type of the keys of the result dictionary</typeparam>
            <typeparam name="TValue">Type of the value of the result dictionary</typeparam>
            <param name="equalityComparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.FullOuterJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},``0,``1,System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on matching keys, including items without pair from both sides.
            </summary>
            <typeparam name="T1">The type of the elements of the first sequence.</typeparam>
            <typeparam name="T2">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="left">The first sequence to join.</param>
            <param name="right">The second sequence to join.</param>
            <param name="leftKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="rightKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="projection">A function to create a result element from two elements.</param>
            <param name="defaultLeft">The default value to use to invoke <paramref name="projection"/> when there is no matching element in first sequence.</param>
            <param name="defaultRight">The default value to use to invoke <paramref name="projection"/> when there is no matching element in second sequence.</param>
            <param name="keyComparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to hash and compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/> that are obtained by performing a full outer join on two sequences.</returns>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.SelectManyUntyped``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.IEnumerable})">
            <summary>
            A SelectMany that returns a non-generic IEnumerable.
            </summary>
        </member>
        <member name="M:Uno.Extensions.EnumerableExtensions.SkipLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Skips the last <paramref name="count"/> items from an enumerable sequence.
            </summary>
            <typeparam name="T">Type of items</typeparam>
            <param name="source">The source enumerable</param>
            <param name="count">Count of items to ignore at the end of an enumerable sequence.</param>
        </member>
        <member name="P:Uno.Extensions.GroupDescriptor`2.Required">
            <summary> Group need to be there even if group is empty </summary>
        </member>
        <member name="T:Uno.Extensions.Specialized.EnumerableExtensions">
            <summary>
            Provides Extensions Methods for IEnumerable.
            </summary>
        </member>
        <member name="M:Uno.Extensions.Specialized.EnumerableExtensions.ForEach(System.Collections.IEnumerable,System.Action{System.Object})">
            <summary>
            Apply an action for every item of an enumerable
            </summary>
            <remarks>
            This method allows looping on every item of the source without enumerating it
            If enumeration is not a concern, you should avoid using this method if you're doing fuctionnal or declarative programming.
            </remarks>
        </member>
        <member name="T:Uno.Extensions.GroupingExtensions">
            <summary>
            Provides Extensions Methods for IGrouping.
            </summary>
        </member>
        <member name="M:Uno.Extensions.GroupingExtensions.ToGroupedDictionary``2(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{``0,``1}})">
            <summary>
            Adapts a IEnumarable of a IGrouping into a IDictionary.
            </summary>
            <typeparam name="TKey">The type of the Key.</typeparam>
            <typeparam name="TElement">The type of the grouped element.</typeparam>
            <param name="items">The groupings to adapt.</param>
            <returns>A Dictionary containing the contents of the grouping.</returns>
        </member>
        <member name="T:Uno.Extensions.ListExtensions">
            <summary>
            Provides Extensions Methods for IList
            </summary>
        </member>
        <member name="M:Uno.Extensions.ListExtensions.AsReadOnly``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns a readonly instance of the specified list.
            </summary>
            <typeparam name="T">The type of the IList</typeparam>
            <param name="items">The list</param>
            <returns>A readonly instance of the specified list.</returns>
        </member>
        <member name="M:Uno.Extensions.ListExtensions.Adapt``2(System.Collections.Generic.IList{``0},System.Func{``1,``0},System.Func{``0,``1})">
            <summary>
            Adapts a list of type T into a list of type U
            </summary>
            <typeparam name="T">The type to adapt.</typeparam>
            <typeparam name="U">The target type.</typeparam>
            <param name="items">The list to adapt</param>
            <param name="from">The function used to adapt a U into a T.</param>
            <param name="to">The function used to adapt a T into a U.</param>
            <returns>A adapted list of the target type.</returns>
        </member>
        <member name="M:Uno.Extensions.ListExtensions.AddOrReplaceRange``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds the items of the specified collection to the end of the ICollection, but only if they
            are not already present.
            </summary>
            <typeparam name="T">The type of the items.</typeparam>
            <param name="list">List in which to insert items.</param>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:Uno.Extensions.ListExtensions.AddOrReplaceRange``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            Adds the items of the specified collection to the end of the ICollection, 
            and updates existing items if they are found by the predicate
            </summary>
            <typeparam name="T">List type</typeparam>
            <param name="list"></param>
            <param name="items"></param>
            <param name="predicate"></param>
        </member>
        <member name="M:Uno.Extensions.ListExtensions.RemoveAllAt``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Remove all items after <paramref name="index"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="index"></param>
        </member>
        <member name="M:Uno.Extensions.ListExtensions.Replace``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean},``0)">
            <summary>
            Replace some items in a list using a selector
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="selector">Select items that have to be replaced</param>
            <param name="replacement">Teh remplacement item</param>
            <returns>Number of items replaced</returns>
        </member>
        <member name="M:Uno.Extensions.ListExtensions.ToDivergentEnumerable``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEnumerable`1"/> by enumerating the given list both backwards and forwards, starting at the given index
            </summary>
            <param name="list">List to enumerate</param>
            <param name="startingAt">Index to start enumerating from</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.ListExtensions.ToDivergentEnumerable``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32)">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEnumerable`1"/> by enumerating the given list both backwards and forwards, starting at the given index
            </summary>
            <param name="list">List to enumerate</param>
            <param name="startingAt">Index to start enumerating from</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.ListExtensions.ContainsIndex``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Gets wether a list contains a given index
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">List to test</param>
            <param name="index">Index to search</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.ListExtensions.ContainsIndex``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32)">
            <summary>
            Gets wether a list contains a given index
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">List to test</param>
            <param name="index">Index to search</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Uno.Extensions.ListExtensions.FindNearestItem``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean},System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Uno.Extensions.ListExtensions.FindNearestItem``1(System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.Boolean},System.Int32)" -->
        <member name="M:Uno.Extensions.ListExtensions.IndexOf(System.Collections.IList,System.Object,System.Collections.IEqualityComparer)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.IList"/>.
            </summary>
            <param name="list">The source list to look into.</param>
            <param name="value">The object to locate in the <see cref="T:System.Collections.IList"/>.</param>
            <param name="comparer">The comparer to use to locate the <paramref name="value" />.</param>
            <returns>The index of value if found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:Uno.Extensions.ListExtensions.SequenceKeyEqual``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            Determines whether two lists are key-equal, using the default <see cref="T:Uno.Equality.KeyEqualityComparer"/> for <see cref="T:Uno.Equality.IKeyEquatable"/>.
            </summary>
            <typeparam name="T">The type of the elements of the input sequences.</typeparam>
            <param name="first">The first list.</param>
            <param name="second">The second list.</param>
            <returns>True if the two source lists are of equal length and their corresponding elements are key-equal; otherwise false.</returns>
        </member>
        <member name="M:Uno.Extensions.ObservableCollectionExtensions.Update``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Updates an ObservableCollection using the provided enumerable, resulting in equal sequences.
            </summary>
            <param name="collection">The collection to update</param>
            <param name="updated">The enumerable to update from</param>
            <param name="tryDispose">Tells the method to try disposing removed items and new items that were not added.
            <param name="comparer"></param>
            <em>ONLY PASS true WHEN USING DIFFERENT INSTANCES THAT USE EQUALS TO MATCH EXISTING INSTANCES. Matching items are not compared by reference.</em></param>
            <remarks>If items come from an AVVM, make sure it's not configured to automatically dispose all previous items. Otherwise, this extension
            will keep items in the collection that are getting disposed by the AVVM.</remarks>
        </member>
        <member name="M:Uno.Extensions.ObservableCollectionExtensions.UpdateWithResults``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Updates an ObservableCollection using the provided enumerable, resulting in equal sequences.
            </summary>
            <param name="collection">The collection to update</param>
            <param name="updated">The enumerable to update from</param>
            <param name="tryDispose">Tells the method to try disposing removed items and new items that were not added.
            <param name="comparer"></param>
            <em>ONLY PASS true WHEN USING DIFFERENT INSTANCES THAT USE EQUALS TO MATCH EXISTING INSTANCES. Matching items are not compared by reference.</em></param>
            <remarks>If items come from an AVVM, make sure it's not configured to automatically dispose all previous items. Otherwise, this extension
            will keep items in the collection that are getting disposed by the AVVM.</remarks>
            <returns>A instance of <see cref="T:Uno.Extensions.ObservableCollectionUpdateResults`1"/> which details what the update has done.</returns>
        </member>
        <member name="M:Uno.Extensions.ObservableCollectionExtensions.UpdateAsync``1(System.Collections.Generic.IList{``0},System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Updates an ObservableCollection using the provided enumerable, resulting in equal sequences. For any item that was
            kept for an equal new instance, UpdateAsync is called if it implements IUpdatable.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="ct"></param>
            <param name="updated"></param>
            <param name="tryDispose"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.ObservableCollectionExtensions.InternalUpdate``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Boolean,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Private version for having a single implementation of adds, removes and updates, but be able to plug async IUpdatable.UpdateAsync call.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="updated"></param>
            <param name="tryDispose"></param>
            <param name="needKept">If true, returns kept item pairs. New items that were kept are <em>NOT</em> disposed.
            We assume the caller will perform the async update, then dispose NewItem.</param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="T:Uno.Extensions.ObservableCollectionUpdateResults`1">
            <summary>
            Provides the results of a call to <see cref="M:Uno.Extensions.ObservableCollectionExtensions.UpdateWithResults``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Collections.Generic.IEqualityComparer{``0})"/> 
            with details about what what was added, moved and removed.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Uno.Extensions.ObservableCollectionUpdateResults`1.Added">
            <summary>
            Gets the added items
            </summary>
        </member>
        <member name="P:Uno.Extensions.ObservableCollectionUpdateResults`1.Moved">
            <summary>
            Gets the moved items
            </summary>
        </member>
        <member name="P:Uno.Extensions.ObservableCollectionUpdateResults`1.Removed">
            <summary>
            Gets the removed items
            </summary>
        </member>
        <member name="T:Uno.Extensions.ActionAsyncExtensions">
            <summary>
            Extensions of <see cref="T:Uno.ActionAsync"/>
            </summary>
        </member>
        <member name="M:Uno.Extensions.ActionAsyncExtensions.SafeInvoke(Uno.ActionAsync,System.Threading.CancellationToken)">
            <summary>
            Invoke the <paramref name="action"/> if not null.
            </summary>
            <param name="action">Action to invoke</param>
            <param name="ct">A CanellationToken</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.ActionAsyncExtensions.SafeInvoke``1(Uno.ActionAsync{``0},System.Threading.CancellationToken,``0)">
            <summary>
            Invoke the <paramref name="action"/> if not null.
            </summary>
            <param name="action">Action to invoke</param>
            <param name="ct">A CanellationToken</param>
            <param name="param">Parameter of action</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.DateTimeExtensions.FromUnixTimeSeconds(System.Int64,System.TimeSpan)">
            <summary>
            Creates a DateTimeOffset from a standard Unix timestamp and offset
            </summary>
            <param name="seconds">Number of seconds since the 1970/01/01 00:00 UTC</param>
            <param name="offset">Offset of the DateTimeOffset</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.DateTimeExtensions.FromUnixTimeMilliseconds(System.Int64,System.TimeSpan)">
            <summary>
            Creates a DateTimeOffset from a standard Unix timestamp and offset
            </summary>
            <param name="seconds">Number of seconds since the 1970/01/01 00:00 UTC</param>
            <param name="offset">Offset of the DateTimeOffset</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.DoubleExtensions.Clamp(System.Double,System.Double,System.Double)">
            <summary>
            Clamps the value between a minimum and maximum (clamping means limiting to a certain range)
            </summary>
            <param name="valueToClamp">value to clamp</param>
            <param name="minimum">minimal value possible</param>
            <param name="maximum">maximum value possible</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.DoubleExtensions.RoundAwayFromZero(System.Double)">
            <summary>
            When a number is halfway between two others, it is rounded toward the nearest number that is away from zero.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.DoubleExtensions.EnsureNumber(System.Double,System.Double)">
            <summary>
            Returns a specified fallback if double is NaN
            </summary>
            <param name="value"></param>
            <param name="targetValueIfNan"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.EnumHelper.GetNames``1">
            <summary>
            This is an alternative to Enum.GetNames() who is faster because are
            not sorting the results
            </summary>
            <remarks>
            The result order is the same than EnumHelper.GetValues().
            Note: Considerer using memoization if called often.
            </remarks>
        </member>
        <member name="M:Uno.Extensions.EnumHelper.GetValues``1">
            <summary>
            This is an alternative to Enum.GetValues() who is faster because are
            not sorting the results.
            </summary>
            <remarks>
            The result order is the same than EnumHelper.GetNames().
            Note: Considerer using memoization if called often.
            </remarks>
        </member>
        <member name="M:Uno.Extensions.ExceptionExtensions.GetPossibleInnerException``1(System.Exception)">
            <summary>
            Determines whether the exception is of the specified type. 
            In the case of an <see cref="T:System.AggregateException"/>, it looks in the inner exceptions.
            </summary>
            <param name="exception">Exception to test</param>
            <typeparam name="TException">The type of the exception to look for</typeparam>
            <returns>The exception instance if found, null otherwise</returns>
        </member>
        <member name="M:Uno.Extensions.ExceptionExtensions.IsOrContainsExceptionType(System.Exception,System.Type)">
            <summary>
            Determines whether the exception is of the specified type. 
            In the case of an <see cref="T:System.AggregateException"/>, it looks in the inner exceptions.
            </summary>
            <param name="exception">Exception to test</param>
            <param name="exceptionType">Type of exception to match</param>
            <returns>True if the exception is or contains an exception of the specified type</returns>
        </member>
        <member name="M:Uno.Extensions.ExceptionExtensions.IsOrContainsExceptionType``1(System.Exception)">
            <summary>
            Determines whether the exception is of the specified type. 
            In the case of an <see cref="T:System.AggregateException"/>, it looks in the inner exceptions .
            </summary>
            <typeparam name="TException">Type of exception to match</typeparam>
            <param name="exception">Exception to test</param>
            <returns>True if the exception is or contains an exception of the specified type</returns>
        </member>
        <member name="T:Uno.Extensions.FuncAsyncExtensions">
            <summary>
            Extensions of <see cref="!:FuncAsync"/>.
            </summary>
        </member>
        <member name="M:Uno.Extensions.FuncAsyncExtensions.SafeInvoke``1(Uno.FuncAsync{``0},System.Threading.CancellationToken)">
            <summary>
            Invoke the <paramref name="func"/> if not null.
            </summary>
            <param name="func">Func to invoke</param>
            <param name="ct">A CanellationToken</param>
            <returns>The result of func, or default(TResult) if the func was null.</returns>
        </member>
        <member name="M:Uno.Extensions.FuncAsyncExtensions.SafeInvoke``2(Uno.FuncAsync{``0,``1},System.Threading.CancellationToken,``0)">
            <summary>
            Invoke the <paramref name="func"/> if not null.
            </summary>
            <param name="func">Func to invoke</param>
            <param name="ct">A CanellationToken</param>
            <param name="param">Parameter of func</param>
            <returns>The result of func, or default(TResult) if the func was null.</returns>
        </member>
        <member name="M:Uno.Extensions.FuncAsyncExtensions.LockInvocation``1(Uno.FuncAsync{``0},Uno.Extensions.InvocationLockingMode)">
            <summary>
            Prevents parallel execution of the FuncAsync
            </summary>
            <param name="func">Func to lock</param>
            <param name="mode">Mode to use for locking</param>
            <returns>A FuncAsync which cannot have nmultiple instance running at a same time</returns>
        </member>
        <member name="M:Uno.Extensions.FuncAsyncExtensions.LockInvocation``2(Uno.FuncAsync{``0,``1},Uno.Extensions.InvocationLockingMode)">
            <summary>
            Prevents parallel execution of the FuncAsync for a SAME PARAMETER
            </summary>
            <param name="func">Func to lock</param>
            <param name="mode">Mode to use for locking FOR A SAME PARAMETER</param>
            <returns>A FuncAsync which cannot have nmultiple instance running at a same time</returns>
        </member>
        <member name="M:Uno.Extensions.FuncExtensions.ApplyMemoized``2(``0,System.Func{``0,``1})">
            <summary>
            Invokes the specified selector on the specified source. The result of the computation will be memoized for the specified source.
            </summary>
            <remarks>
            This method uses the selector instance to associate the results to the source instance. 
            Make sure to use a stable instance, e.g. not a lambda with closures over local or instance variables.
            </remarks>
            <typeparam name="TSource">The type of the parameter</typeparam>
            <typeparam name="TResult">The type of the computation result</typeparam>
            <param name="source">The source instance.</param>
            <param name="selector">The method group to use.</param>
            <returns>The memoized result</returns>
        </member>
        <member name="M:Uno.Extensions.FuncExtensions.ApplyMemoized``3(``0,System.Func{``0,``2,``1},``2)">
            <summary>
            Invokes the specified selector on the specified source, with the specified parameter. The result of the computation will be memoized for the specified source and parameter.
            </summary>
            <remarks>
            This method uses the selector instance to associate the results to the source instance. 
            Make sure to use a stable instance, e.g. not a lambda with closures over local or instance variables.
            </remarks>
            <typeparam name="TSource">The type of the parameter</typeparam>
            <typeparam name="TResult">The type of the computation result</typeparam>
            <typeparam name="TParam">A parameter to pass the selector call</typeparam>
            <param name="source">The source instance.</param>
            <param name="selector">The method group to use.</param>
            <returns>The memoized result</returns>
        </member>
        <member name="M:Uno.Extensions.FuncExtensions.ApplyMemoized``4(``0,System.Func{``0,``2,``3,``1},``2,``3)">
            <summary>
            Invokes the specified selector on the specified source, with the specified parameters. The result of the computation will be memoized for the specified source and parameters.
            </summary>
            <remarks>
            This method uses the selector instance to associate the results to the source instance. 
            Make sure to use a stable instance, e.g. not a lambda with closures over local or instance variables.
            </remarks>
            <typeparam name="TSource">The type of the parameter</typeparam>
            <typeparam name="TResult">The type of the computation result</typeparam>
            <typeparam name="TParam1">A parameter to pass the selector call</typeparam>
            <typeparam name="TParam2">A parameter to pass the selector call</typeparam>
            <param name="source">The source instance.</param>
            <param name="selector">The method group to use.</param>
            <returns>The memoized result</returns>
        </member>
        <member name="M:Uno.Extensions.FuncExtensions.AsWeakMemoized``2(System.Func{``0,``1},``0)">
            <summary>
            Creates a func that invokes the specified selector on the specified source. The result of the computation will be memoized for the specified source.
            </summary>
            <typeparam name="TSource">The type of the parameter</typeparam>
            <typeparam name="TResult">The type of the computation result</typeparam>
            <param name="source">The source instance.</param>
            <param name="selector">The method group to use.</param>
            <returns>A function that will return the memoized result</returns>
        </member>
        <member name="M:Uno.Extensions.FuncExtensions.AsWeakMemoized``3(System.Func{``0,``2,``1},``0)">
            <summary>
            Creates a func that invokes the specified selector on the specified source, with the specified parameter. The result of the computation will be memoized for the specified source and parameter.
            </summary>
            <typeparam name="TSource">The type of the parameter</typeparam>
            <typeparam name="TResult">The type of the computation result</typeparam>
            <typeparam name="TParam">A parameter to pass the selector call</typeparam>
            <param name="source">The source instance.</param>
            <param name="selector">The method group to use.</param>
            <returns>A function that will return the memoized result</returns>
        </member>
        <member name="M:Uno.Extensions.FuncExtensions.AsWeakMemoized``4(System.Func{``0,``2,``3,``1},``0)">
            <summary>
            Creates a func that invokes the specified selector on the specified source, with the specified parameters. The result of the computation will be memoized for the specified source and parameters.
            </summary>
            <typeparam name="TSource">The type of the parameter</typeparam>
            <typeparam name="TResult">The type of the computation result</typeparam>
            <typeparam name="TParam1">A parameter to pass the selector call</typeparam>
            <typeparam name="TParam2">A parameter to pass the selector call</typeparam>
            <param name="selector">The method group to use.</param>
            <param name="source">The source instance.</param>
            <returns>A function that will return the memoized result</returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsMemoized``1(System.Func{``0})">
            <summary>
            Parameter less memoizer, used to perform a lazy-cached evaluation. (see http://en.wikipedia.org/wiki/Memoization)
            </summary>
            <typeparam name="T">The return type to memoize</typeparam>
            <param name="func">the function to evaluate</param>
            <returns>A memoized value</returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsMemoized``2(System.Func{``0,``1})">
            <summary>
            Memoizer with one parameter, used to perform a lazy-cached evaluation. (see http://en.wikipedia.org/wiki/Memoization)
            </summary>
            <typeparam name="TParam">The return type to memoize</typeparam>
            <param name="func">the function to evaluate</param>
            <returns>A memoized value</returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsMemoized``3(System.Func{``0,``1,``2})">
            <summary>
            Memoizer with two parameters, used to perform a lazy-cached evaluation. (see http://en.wikipedia.org/wiki/Memoization)
            </summary>
            <typeparam name="TParam1">The first parameter type to memoize</typeparam>
            <typeparam name="TParam2">The second parameter type to memoize</typeparam>
            <param name="func">the function to evaluate</param>
            <returns>A memoized value</returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsMemoized``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Memoizer with three parameters, used to perform a lazy-cached evaluation. (see http://en.wikipedia.org/wiki/Memoization)
            </summary>
            <typeparam name="TParam1">The first parameter type to memoize</typeparam>
            <typeparam name="TParam2">The second parameter type to memoize</typeparam>
            <typeparam name="TParam3">The third parameter type to memoize</typeparam>
            <param name="func">the function to evaluate</param>
            <returns>A memoized value</returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsMemoized``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Memoizer with four parameters, used to perform a lazy-cached evaluation. (see http://en.wikipedia.org/wiki/Memoization)
            </summary>
            <typeparam name="TParam1">The first parameter type to memoize</typeparam>
            <typeparam name="TParam2">The second parameter type to memoize</typeparam>
            <typeparam name="TParam3">The third parameter type to memoize</typeparam>
            <typeparam name="TParam4">The fourth parameter type to memoize</typeparam>
            <param name="func">the function to evaluate</param>
            <returns>A memoized value</returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsMemoized``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Memoizer with five parameters, used to perform a lazy-cached evaluation. (see http://en.wikipedia.org/wiki/Memoization)
            </summary>
            <typeparam name="TParam1">The first parameter type to memoize</typeparam>
            <typeparam name="TParam2">The second parameter type to memoize</typeparam>
            <typeparam name="TParam3">The third parameter type to memoize</typeparam>
            <typeparam name="TParam4">The fourth parameter type to memoize</typeparam>
            <typeparam name="TParam5">The fifth parameter type to memoize</typeparam>
            <param name="func">the function to evaluate</param>
            <returns>A memoized value</returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsMemoized``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})">
            <summary>
            Creates a parameter-less memoizer for the the specified task provider. The task provider is guaranteed to be executed only once.
            </summary>
            <typeparam name="T">The return value type</typeparam>
            <param name="func">A function that will call the create the task.</param>
            <returns>A function that will return a task </returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsMemoized``2(System.Func{System.Threading.CancellationToken,``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Creates a memoizer with one parameter for the the specified task provider. The task provider is guaranteed to be executed only once per parameter instance.
            </summary>
            <typeparam name="TResult">The return value type</typeparam>
            <typeparam name="TParam"></typeparam>
            <param name="func">A function that will call the create the task.</param>
            <returns>A function that will return a task </returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsMemoized``1(Uno.FuncAsync{``0})">
            <summary>
            Creates a parameter-less memoizer for the the specified task provider. The task provider is guaranteed to be executed only once.
            </summary>
            <typeparam name="T">The return value type</typeparam>
            <param name="func">A function that will call the create the task.</param>
            <returns>A function that will return a task </returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsMemoized``2(Uno.FuncAsync{``0,``1})">
            <summary>
            Creates a memoizer with one parameter for the the specified task provider. The task provider is guaranteed to be executed only once per parameter instance.
            </summary>
            <typeparam name="TResult">The return value type</typeparam>
            <typeparam name="TParam"></typeparam>
            <param name="func">A function that will call the create the task.</param>
            <returns>A function that will return a task </returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsLockedMemoized``1(System.Func{``0})">
            <summary>
            Parameter less thread-safe memoizer, used to perform a lazy-cached evaluation. (see http://en.wikipedia.org/wiki/Memoization)
            </summary>
            <typeparam name="T">The return type to memoize</typeparam>
            <param name="func">the function to evaluate</param>
            <returns>A memoized value</returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsLockedMemoized``2(System.Func{``0,``1})">
            <summary>
            Memoizer with one parameter, used to perform a lazy-cached evaluation. (see http://en.wikipedia.org/wiki/Memoization)
            </summary>
            <typeparam name="T">The return type to memoize</typeparam>
            <param name="func">the function to evaluate</param>
            <returns>A memoized value</returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsLockedMemoized``3(System.Func{``0,``1,``2})">
            <summary>
            Memoizer with two parameters, used to perform a lazy-cached evaluation. (see http://en.wikipedia.org/wiki/Memoization)
            </summary>
            <typeparam name="T">The return type to memoize</typeparam>
            <param name="func">the function to evaluate</param>
            <returns>A memoized value</returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsLockedMemoized``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Memoizer with three parameters, used to perform a lazy-cached evaluation. (see http://en.wikipedia.org/wiki/Memoization)
            </summary>
            <typeparam name="T">The return type to memoize</typeparam>
            <param name="func">the function to evaluate</param>
            <returns>A memoized value</returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsLockedMemoized``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Memoizer with four parameters, used to perform a lazy-cached evaluation. (see http://en.wikipedia.org/wiki/Memoization)
            </summary>
            <typeparam name="T">The return type to memoize</typeparam>
            <param name="func">the function to evaluate</param>
            <returns>A memoized value</returns>
        </member>
        <member name="M:Uno.Extensions.FuncMemoizeExtensions.AsWeakLockedMemoized``2(System.Func{``0,``1})">
            <summary>
            Memoizer with one parameter (kept as weak reference), used to perform a lazy-cached evaluation. (see http://en.wikipedia.org/wiki/Memoization)
            </summary>
            <typeparam name="TParam">The return type to memoize</typeparam>
            <param name="func">the function to evaluate</param>
            <returns>A memoized value</returns>
        </member>
        <member name="P:Uno.Extensions.IIndentedStringBuilder.CurrentLevel">
            <summary>
            Gets the current indentation level
            </summary>
        </member>
        <member name="M:Uno.Extensions.IIndentedStringBuilder.Append(System.String)">
            <summary>
            Appends text using the current indentation level
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:Uno.Extensions.IIndentedStringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Appends formatted text using the current indentation level
            </summary>
        </member>
        <member name="M:Uno.Extensions.IIndentedStringBuilder.AppendLine">
            <summary>
            Appends a line using the current indentation level 
            </summary>
        </member>
        <member name="M:Uno.Extensions.IIndentedStringBuilder.AppendLine(System.String)">
            <summary>
            Writes the provided text and adds line using the current indentation level 
            </summary>
        </member>
        <member name="M:Uno.Extensions.IIndentedStringBuilder.Block(System.Int32)">
            <summary>
            Creates an indentation block
            </summary>
            <param name="count">The indentation level of the new block.</param>
            <returns>A disposable that will close the block</returns>
        </member>
        <member name="M:Uno.Extensions.IIndentedStringBuilder.Block(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Creates an indentation block, e.g. using a C# curly braces.
            </summary>
            <returns>A disposable that will close the block</returns>
        </member>
        <member name="M:Uno.Extensions.IIndentedStringBuilder.Indent(System.Int32)">
            <summary>
            Adds an indentation 
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.IIndentedStringBuilder.ToString">
            <summary>
            Provides a string representing the complete builder.
            </summary>
        </member>
        <member name="T:Uno.Extensions.IndentedStringBuilder">
            <summary>
            A C# code indented builder.
            </summary>
        </member>
        <member name="M:Uno.Extensions.IndentedStringBuilder.AppendLine">
            <summary>
            Appends a newline.
            </summary>
            <remarks>
            This method presents correct behavior, as opposed to its <see cref="M:Uno.Extensions.IndentedStringBuilder.AppendLine(System.String)"/>
            overload. Therefore, this method should be used whenever a newline is desired.
            </remarks>
        </member>
        <member name="M:Uno.Extensions.IndentedStringBuilder.AppendLine(System.String)">
            <summary>
            Appends the given string, *without* appending a newline at the end.
            </summary>
            <param name="text">The string to append.</param>
            <remarks>
            Even though this method seems like it appends a newline, it doesn't. To append a
            newline, call <see cref="M:Uno.Extensions.IndentedStringBuilder.AppendLine"/> after this method, as the parameterless
            overload has the correct behavior.
            </remarks>
        </member>
        <member name="T:Uno.Extensions.InvocationLockingMode">
            <summary>
            Modes for asynchronous action / func invocation lock
            </summary>
        </member>
        <member name="F:Uno.Extensions.InvocationLockingMode.Serial">
            <summary>
            Invocations are queued and sequencially
            </summary>
        </member>
        <member name="F:Uno.Extensions.InvocationLockingMode.Share">
            <summary>
            Invocation re-use result of any pending running instance
            </summary>
        </member>
        <member name="M:Uno.Extensions.ObjectExtensions.Apply``2(``0,System.Func{``0,``1})">
            <summary>
            A helper method to allow for locally defined extension-method like methods. Avoids the creation of an external static class
            in the context of fluent expressions.
            </summary>
        </member>
        <member name="M:Uno.Extensions.ObjectExtensions.Apply``1(``0,System.Action{``0})">
            <summary>
            A helper method that allows the execution of an action in a fluent expression.
            </summary>
            <param name="action">The action to execute on the source object</param>
            <returns>The source instance</returns>
        </member>
        <member name="M:Uno.Extensions.ObjectExtensions.Apply``1(``0,System.Boolean,System.Action{``0})">
            <summary>
            A helper method that allows the execution of an action in a fluent expression. The action will be executed if the condition is true.
            </summary>
            <param name="condition">A boolean value that indicates if the action should be executed.</param>
            <param name="action">The action to execute, the parameter will contain source</param>
            <returns>Returns the source instance</returns>
        </member>
        <member name="M:Uno.Extensions.ObjectExtensions.IsOneOf``1(``0,``0[])">
            <summary>
            Gets a boolean value that determines if a specific value is within a list of accepted values.
            Use this when it's not necessary or when it's overkill to declare the list of accepted values
            as a readonly field. For example, can be used to check if one enum value is within a set without that
            enum being marked as [Flags].
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="source">The source value.</param>
            <param name="acceptedValues">The list of accepted values.</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.ObjectExtensions.IsOneOf``1(``0,System.Collections.Generic.IEqualityComparer{``0},``0[])">
            <summary>
            Gets a boolean value that determines if a specific value is within a list of accepted values.
            Use this when it's not necessary or when it's overkill to declare the list of accepted values
            as a readonly field. For example, can be used to check if one enum value is within a set without that
            enum being marked as [Flags].
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="source">The source value.</param>
            <param name="comparer">The comparer to use to determine equality.</param>
            <param name="acceptedValues">The list of accepted values.</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.StreamExtensions.ReadToEnd(System.IO.Stream)">
            <summary>
            Reads the text container into the specified stream.
            </summary>
            <param name="stream"></param>
            <returns>The string using the default encoding.</returns>
            <remarks>The stream will be disposed when calling this method.</remarks>
        </member>
        <member name="M:Uno.Extensions.StreamExtensions.ReadToEnd(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Reads the text container into the specified stream.
            </summary>
            <param name="stream"></param>
            <returns>The string using the default encoding.</returns>
            <remarks>The stream will be disposed when calling this method.</remarks>
        </member>
        <member name="M:Uno.Extensions.StreamExtensions.StartsWith(System.IO.Stream,System.Byte[])">
            <summary>
            Warning, if stream cannot be seek, will read from current position!
            Warning, stream position will not been restored!
            </summary>
            <param name="stream"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.StreamExtensions.ToMemoryStream(System.IO.Stream)">
            <summary>
            Create a MemoryStream, copy <see cref="!:source"/> to it, and set position to 0.
            </summary>
            <param name="source">Stream to copy</param>
            <returns>Newly created memory stream, position set to 0</returns>
        </member>
        <member name="M:Uno.Extensions.StreamExtensions.ToSeekable(System.IO.Stream)">
            <summary>
            Check if <see cref="!:stream"/> is seekable (CanSeek), if not copy it to a MemoryStream. 
            WARNING: Some stream (like UnmanagedMemoryStream) return CanSeek = true but are not seekable. Prefer using ToMemoryStream() to be 100% safe.
            </summary>
            <param name="stream">A stream</param>
            <returns>A seekable stream (orginal if seekable, a MemoryStream copy of <see cref="!:stream"/> else)</returns>
        </member>
        <member name="M:Uno.Extensions.StringExtensions.Contains(System.String,System.String,System.StringComparison)">
            <summary>
            Check if the specified string occures in the current System.String object. A parameter specifies the type of search to use for the specified string.
            </summary>
            <param name="instance"></param>
            <param name="value">The string to seek.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.StringExtensions.IsNumber(System.String)">
            <summary>
            Check if every characters in the string is considered as a "Unicode Number". WARNING: READ REMARKS!!
            </summary>
            <remarks>
             In addition to including digits, numbers include characters, fractions, subscripts, superscripts,
            Roman numerals, currency numerators, and encircled numbers. This method contrasts with the IsDigit
            method, which determines whether a Char is a radix-10 digit.
            </remarks>
        </member>
        <member name="M:Uno.Extensions.StringExtensions.IsDigit(System.String)">
            <summary>
            Check if every characters in the string is considered as a "Unicode Decimal Digit". (char 0-9)
            </summary>
            <remarks>
            This contrasts with IsNumber, which determines whether a Char is of any numeric Unicode category.
            Numbers include characters such as fractions, subscripts, superscripts, Roman numerals,
            currency numerators, encircled numbers, and script-specific digits.
            </remarks>
        </member>
        <member name="M:Uno.Extensions.StringExtensions.Left(System.String,System.Int32)">
            <summary>
            Returns a string that contains a specified number of characters from the left side of a string.
            </summary>
            <param name="instance"><see cref="T:System.String"/> expression from which the leftmost characters are returned.</param>
            <param name="length"><see cref="T:System.Int32"/> expression. Numeric expression indicating how many characters to return.</param>
            <returns>If zero, a zero-length string ("") is returned. If greater than or equal to the number of characters in value, the complete string is returned.</returns>
            <exception cref="T:System.ArgumentException">length &lt; 0</exception>
        </member>
        <member name="M:Uno.Extensions.StringExtensions.Right(System.String,System.Int32)">
            <summary>
            Returns a string containing a specified number of characters from the right side of a string.
            </summary>
            <param name="instance"><see cref="T:System.String"/> expression from which the rightmost characters are returned.</param>
            <param name="length"><see cref="T:System.Int32"/> expression. Numeric expression indicating how many characters to return.</param>
            <returns>If zero, a zero-length string ("") is returned. If greater than or equal to the number of characters in value, the complete string is returned.</returns>
            <exception cref="T:System.ArgumentException">length &lt; 0</exception>
        </member>
        <member name="M:Uno.Extensions.StringExtensions.LeftRightInternal(System.String,System.Int32,System.Func{System.String})">
            <summary>
            Returns a string that contains a specified number of characters of a string.
            </summary>
            <param name="instance"><see cref="T:System.String"/> expression from which the characters are returned.</param>
            <param name="length"><see cref="T:System.Int32"/> expression. Numeric expression indicating how many characters to return.</param>
            <param name="predicate">Func <see cref="T:System.String"/> expression that returns the substring.</param>
        </member>
        <member name="M:Uno.Extensions.StringExtensions.Append(System.String,System.String)">
            <summary>
            Append a chunk at the end of a string
            </summary>
            <param name="target">target string object</param>
            <param name="chunk">Chunk to add</param>
            <returns>New string with the chunk at appended at the end.</returns>
        </member>
        <member name="M:Uno.Extensions.StringExtensions.Append(System.String,System.String,System.Func{System.String,System.Boolean})">
            <summary>
            Append a chunk at the end of a string only if the condition is met.
            </summary>
            <param name="target">target string object</param>
            <param name="chunk">Chunk to add</param>
            <param name="condition">Condition to meet for the chunk to be added</param>
            <returns>New string with the chunk at appended at the end or original string if condition is not met.</returns>
        </member>
        <member name="M:Uno.Extensions.StringExtensions.AppendIfMissing(System.String,System.String)">
            <summary>
            Append a chunk at the end of a string only if the string doen't end by it.
            </summary>
            <param name="target">target string object</param>
            <param name="chunk">Chunk to add</param>
            <returns>New string with the chunk at appended at the end or the original string if the target already end by chunk.</returns>
        </member>
        <member name="M:Uno.Extensions.StringExtensions.TrimStart(System.String,System.String)">
            <summary>
            Removes all leading occurrences of <see cref="!:trimText"/> from the current System.String object
            </summary>
            <param name="trimText">A string to remove</param>
            <returns>The string that remains after all occurrences of the <see cref="!:trimText"/> are removed from the start of the current string.</returns>
        </member>
        <member name="M:Uno.Extensions.StringExtensions.TrimEnd(System.String,System.String)">
            <summary>
            Removes all trailing occurrences of <see cref="!:trimText"/> from the current System.String object
            </summary>
            <param name="trimText">A string to remove</param>
            <returns>The string that remains after all occurrences of the <see cref="!:trimText"/> are removed from the end of the current string.</returns>
        </member>
        <member name="M:Uno.Extensions.StringExtensions.UppercaseFirst(System.String)">
            <summary>
            Uppercases the first character of the string.
            If the string is <c>null</c> or <c>""</c> then it returns <c>string.Empty</c>
            </summary>
            <param name="s">The string.</param>
            <returns>The string where the first character is in uppercase or <c>string.Empty</c> if the string is <c>null</c> or <c>""</c></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Uno.Extensions.StringExtensions.RemoveDiacritics(System.String)" -->
        <member name="M:Uno.Extensions.StringExtensions.Format(System.String,System.Object[])">
            <summary>
            Improves upon <see cref="M:System.String.Format(System.String,System.Object[])"/> to allow a 4th and 5th
            group in numerical custom formats, for values 1 and -1. See <see cref="M:Uno.Extensions.StringExtensions.Format(System.IFormatProvider,System.String,System.Object[])"/>
            for details.
            </summary>
            <param name="format"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.StringExtensions.Format(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Improves upon <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/> to allow a 4th and 5th
            group in numerical custom formats, for values 1 and -1. Just like the 3rd group, which applies to value 0,
            these groups will get used if the first group (positive) or second group (negative) would display the same
            string as if 1 or -1 was the argument. For example, given the en-US culture, the "{0:C;C;broke;a buck}"
            format would display "$1.42" for value 1.42, display "broke" for values 0, -0.004 or 0.003, and display
            "a buck" for values 0.995, 1 or 1.0025.
            </summary>
            <param name="provider"></param>
            <param name="format"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.UriExtensions.EscapeDataString(System.String)">
            <summary>
            Converts a string to its escaped representation.
            This extension bypasses the Uri.EscapeDataString characters limit.
            </summary>
            Source: http://stackoverflow.com/questions/6695208/uri-escapedatastring-invalid-uri-the-uri-string-is-too-long
        </member>
        <member name="P:Uno.Extensions.LogExtensionPoint.AmbientLoggerFactory">
            <summary>
            Retreives the <see cref="T:Microsoft.Extensions.Logging.ILoggerFactory"/> for this the Uno extension point.
            </summary>
        </member>
        <member name="M:Uno.Extensions.LogExtensionPoint.Log(System.Type)">
            <summary>
            Gets a <see cref="T:Microsoft.Extensions.Logging.ILogger"/> for the specified type.
            </summary>
            <param name="forType"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Extensions.LogExtensionPoint.Log``1(``0)">
            <summary>
            Gets a logger instance for the current types
            </summary>
            <typeparam name="T">The type for which to get the logger</typeparam>
            <param name="instance"></param>
            <returns>A logger for the type of the instance</returns>
        </member>
        <member name="M:Uno.Extensions.TypeExtensions.GetAllInterfaces(System.Type)">
            <summary>
            Recursively get all interfaces of a type
            </summary>
        </member>
        <member name="M:Uno.Extensions.TypeExtensions.GetBaseTypes(System.Type)">
            <summary>
            Gets the inheritance hierarchy of supplied type.
            </summary>
        </member>
        <member name="M:Uno.Extensions.TypeExtensions.GetFlattenedDeclaredProperty(System.Type,System.String)">
            <summary>
            Gets the declared property by searching the flattened hierarchy.
            </summary>
            <param name="type">The type to search into</param>
            <param name="name">The name of the declared property</param>
            <returns>The property info if found, otherwise null.</returns>
        </member>
        <member name="M:Uno.Extensions.TypeExtensions.GetFlattenedDeclaredField(System.Type,System.String)">
            <summary>
            Gets the declared field by searching the flattened hierarchy.
            </summary>
            <param name="type">The type to search into</param>
            <param name="name">The name of the declared field</param>
            <returns>The field info if found, otherwise null.</returns>
        </member>
        <member name="T:Uno.Extensions.MatchExtensions">
            <summary>
            Provide extentions for the System.Text.RegularExpressions.Match class
            </summary>
        </member>
        <member name="M:Uno.Extensions.MatchExtensions.AsEnumerable(System.Text.RegularExpressions.Match)">
            <summary>
            Converts a Regular Expression Match instance to an enumerable of Regular Expression Match instances
            </summary>
            <param name="match">A Regular Expression Match instance</param>
            <returns>An enumerable of matches</returns>
        </member>
        <member name="M:Uno.Extensions.SynchronizableExtensions.Write``1(Uno.Threading.ISynchronizableLock{``0},System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>
            Performs a write operation if the read operation returns false.
            </summary>
            <param name="read">A lambda that will test if the data can be read</param>
            <param name="write">A lambda that will perform the write if the read failed</param>
            <returns>true if the read succeeded, otherwise false.</returns>
        </member>
        <member name="M:Uno.TaskUtilities.Timeout(System.Threading.CancellationToken,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.TimeSpan,System.Action)">
            <summary>
            Executes a provided <see cref="T:System.Threading.Tasks.Task"/>, cancelling the task and executing a fallback action if the Task doesn't complete before the provided timeout.
            </summary>
            <param name="ct"></param>
            <param name="taskSelector"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.TaskUtilities.Timeout(System.Threading.CancellationToken,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.TimeSpan)">
            <summary>
            Executes a provided <see cref="T:System.Threading.Tasks.Task"/>, cancelling the task and throwing a <see cref="T:System.TimeoutException"/> if the Task doesn't complete before the provided timeout.
            </summary>
            <param name="ct"></param>
            <param name="taskSelector"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.TaskUtilities.Timeout``1(System.Threading.CancellationToken,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}},System.TimeSpan,System.Func{``0})">
            <summary>
            Executes a provided <see cref="T:System.Threading.Tasks.Task"/>, cancelling the task and executing a special selector if the Task doesn't complete before the provided timeout.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ct"></param>
            <param name="taskSelector"></param>
            <param name="timeout"></param>
            <param name="timedOutValueSelector"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.TaskUtilities.Timeout``1(System.Threading.CancellationToken,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}},System.TimeSpan)">
            <summary>
            Executes a provided <see cref="T:System.Threading.Tasks.Task"/>, cancelling the task and throwing a <see cref="T:System.TimeoutException"/> if the Task doesn't complete before the provided timeout.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ct"></param>
            <param name="taskSelector"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="T:Uno.Builder.BuilderContext`1">
            <summary>
            A context that helps the creation of an IBuilder based builder.
            </summary>
            <typeparam name="TOwner"></typeparam>
        </member>
        <member name="T:Uno.Builder.BuilderContext">
            <summary>
            A context that helps the creation of an IBuilder based builder.
            </summary>
            <typeparam name="TOwner"></typeparam>
        </member>
        <member name="M:Uno.Builder.BuilderContext.BuildDependencies">
            <summary>
            Builds this builder dependencies
            </summary>
        </member>
        <member name="M:Uno.Builder.BuilderContext.AppendBuildDependency(System.Action)">
            <summary>
            Appends an action to be executed after this builder has been built
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Uno.Builder.BuilderContext.Create``1(``0)">
            <summary>
            Creates a builder context for the specified owner
            </summary>
            <typeparam name="TOwner"></typeparam>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Builder.BuilderContext.GetOrCreateBuilder``1(System.Object,System.String,System.Func{``0})">
            <summary>
            Gets the specified builder on the specified owner instance
            </summary>
            <param name="owner">The instance on which the new builder will be attached</param>
            <param name="name">The named instance</param>
            <param name="builder">The selector that will create a new builder instance</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Builder.BuilderContext.GetOrCreateBuilder``2(``0,System.String,System.Func{``1,``1},System.Func{``1})">
            <summary>
            Gets the specified builder on the specified owner instance
            </summary>
            <param name="owner">The instance on which the new builder will be attached</param>
            <param name="name">The named instance</param>
            <param name="builder">The selector that will create a new builder instance</param>
            <param name="selector">The builder select that will configure the builder</param>
            <returns></returns>
        </member>
        <member name="T:Uno.Builder.IBuilder">
            <summary>
            Defines a builder
            </summary>
        </member>
        <member name="M:Uno.Builder.IBuilder.AppendBuild(System.Action)">
            <summary>
            Appends a build action when the parent builder is built
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Uno.Builder.IBuilder.Build">
            <summary>
            Builds the current builder
            </summary>
        </member>
        <member name="T:Uno.Builder.IBuilder`1">
            <summary>
            Defines a builder typed with its owner
            </summary>
            <typeparam name="TOwner"></typeparam>
        </member>
        <member name="P:Uno.Builder.IBuilder`1.Owner">
            <summary>
            The owner instance of this builder
            </summary>
        </member>
        <member name="T:Uno.CachedTuple">
            <summary>
            A tuple implementation that caches the GetHashCode value for faster lookup performance.
            </summary>
        </member>
        <member name="M:Uno.CachedTuple.Create``2(``0,``1)">
            <summary>
            Creates a tuple with two values.
            </summary>
        </member>
        <member name="M:Uno.CachedTuple.Create``3(``0,``1,``2)">
            <summary>
            Creates a tuple with three values.
            </summary>
        </member>
        <member name="M:Uno.CachedTuple.Create``4(``0,``1,``2,``3)">
            <summary>
            Creates a tuple with four values.
            </summary>
        </member>
        <member name="T:Uno.CachedTuple`2">
            <summary>
            A tuple with two values implementation that caches the GetHashCode value for faster lookup performance.
            </summary>
        </member>
        <member name="F:Uno.CachedTuple`2.Comparer">
            <summary>
            Gets a comparer for the current tuple
            </summary>
        </member>
        <member name="T:Uno.CachedTuple`3">
            <summary>
            A tuple with three values implementation that caches the GetHashCode value for faster lookup performance.
            </summary>
        </member>
        <member name="F:Uno.CachedTuple`3.Comparer">
            <summary>
            Gets a comparer for the current tuple
            </summary>
        </member>
        <member name="T:Uno.CachedTuple`4">
            <summary>
            A tuple with four values implementation that caches the GetHashCode value for faster lookup performance.
            </summary>
        </member>
        <member name="T:Uno.Collections.CollectionAdapter`2">
            <summary>
            Adapts a collection of type T into a collection of type U
            </summary>
            <typeparam name="T">Original type</typeparam>
            <typeparam name="U">Target type</typeparam>
        </member>
        <member name="M:Uno.Collections.CollectionAdapter`2.#ctor(System.Collections.Generic.ICollection{`0},System.Func{`1,`0},System.Func{`0,`1})">
            <summary>
            Constructs a CollectionAdapter
            </summary>
            <param name="target">Collection of type T to adapt.</param>
            <param name="from">Function used to adapt a U into a T.</param>
            <param name="to">Function used to adapt a T into a U.</param>
        </member>
        <member name="P:Uno.Collections.CollectionAdapter`2.Enumerable">
            <summary>
            Returns the adapter.
            </summary>
        </member>
        <member name="M:Uno.Collections.CollectionAdapter`2.Add(`1)">
            <summary>
            See base.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Uno.Collections.CollectionAdapter`2.Clear">
            <summary>
            See base.
            </summary>
        </member>
        <member name="M:Uno.Collections.CollectionAdapter`2.Contains(`1)">
            <summary>
            See base.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Collections.CollectionAdapter`2.CopyTo(`1[],System.Int32)">
            <summary>
            See base.
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="P:Uno.Collections.CollectionAdapter`2.Count">
            <summary>
            See base.
            </summary>
        </member>
        <member name="P:Uno.Collections.CollectionAdapter`2.IsReadOnly">
            <summary>
            See base.
            </summary>
        </member>
        <member name="M:Uno.Collections.CollectionAdapter`2.Remove(`1)">
            <summary>
            See base.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Collections.CollectionAdapter`2.GetEnumerator">
            <summary>
            See base.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Uno.Collections.CollectionAdapter`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            See base.
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Uno.Collections.ConcatenatingDictionary" -->
        <member name="T:Uno.Collections.ImmutableList`1">
            <summary>
            An immutable list implementation, designed for safe concurrent access.
            </summary>
            <remarks>
            It is possible to mutate the content of this immutable list. Not all
            protections are in place to ensure a perfect immutability. Don't use it
            if you are exposing it outside your code. For true immutability
            protection, you should prefer those from Micrososft's Immutable Collections.
            </remarks>
        </member>
        <member name="P:Uno.Collections.ImmutableList`1.Empty">
            <summary>
            Provides an empty list
            </summary>
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.#ctor">
            <summary>
            Creates an empty list
            </summary>
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.#ctor(`0[],System.Boolean)">
            <summary>
            Initializes the list with the provided array.
            </summary>
            <param name="data">An array as source</param>
            <param name="copyData">If the array should be copied</param>
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes the list with the provided array.
            </summary>
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.System#Collections#Immutable#IImmutableList{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.Remove(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.RemoveAll(System.Predicate{`0})">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.RemoveRange(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.System#Collections#Immutable#IImmutableList{T}#RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.SetItem(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.Replace(`0,`0,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.Add(`0)">
            <summary>
            Returns a new list with the specifed value appended at the end.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.Remove(`0)">
            <summary>
            Returns a new list with specified value removed.
            </summary>
            <param name="value">The value to remove</param>
            <returns>A new list</returns>
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.Contains(`0)">
            <summary>
            Determines whether the list contains a specified element
            </summary>
            <param name="value">The value to locate.</param>
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the specified index.
            </summary>
            <param name="index">The index to remove</param>
            <returns>A new list with the item removed</returns>
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.IndexOf(`0)">
            <summary>
            Returns the index of the specified value
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:Uno.Collections.ImmutableList`1.Data">
            <summary>
            The underlying data available for thread-safe access
            </summary>
            <remarks>
            Please, don't mutate it! There's not protection against this.
            </remarks>
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ImmutableList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:Uno.Collections.ImmutableList`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Uno.Collections.ImmutableList`1.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Uno.Collections.ListAdapter`2.IndexOf(`1)">
            <summary>
            See base.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Collections.ListAdapter`2.Insert(System.Int32,`1)">
            <summary>
            See base.
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Uno.Collections.ListAdapter`2.RemoveAt(System.Int32)">
            <summary>
            See base.
            </summary>
            <param name="index"></param>
        </member>
        <member name="P:Uno.Collections.ListAdapter`2.Item(System.Int32)">
            <summary>
            See base.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.SelectToSpan``2(System.Collections.Generic.List{``0},System.Span{``1},System.Func{``0,``1})">
            <summary>
            Selects the values of a <see cref="T:System.Collections.Generic.List`1"/> to a pre-allocated <see cref="T:System.Span`1"/>.
            </summary>
            <typeparam name="TIn">The input type</typeparam>
            <typeparam name="TOut">The output type</typeparam>
            <param name="list">The <see cref="T:System.Collections.Generic.List`1"/> to be projected</param>
            <param name="span">The output span</param>
            <param name="selector">A selector method that projects <typeparamref name="TIn"/> to <typeparamref name="TOut"/></param>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.SelectToSpan``2(System.Span{``0},System.Span{``1},System.Func{``0,``1})">
            <summary>
            Selects the values of a <see cref="T:System.Span`1"/> to a pre-allocated <see cref="T:System.Span`1"/>.
            </summary>
            <typeparam name="TIn">The input type</typeparam>
            <typeparam name="TOut">The output type</typeparam>
            <param name="list">The <see cref="T:System.Span`1"/> to be projected</param>
            <param name="span">The output span</param>
            <param name="selector">A selector method that projects <typeparamref name="TIn"/> to <typeparamref name="TOut"/></param>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.SelectToSpan``2(System.Span{``0},System.Span{``1},System.Func{``0,System.Int32,``1})">
            <summary>
            Selects the values of a <see cref="T:System.Span`1"/> to a pre-allocated <see cref="T:System.Span`1"/>.
            </summary>
            <typeparam name="TIn">The input type</typeparam>
            <typeparam name="TOut">The output type</typeparam>
            <param name="list">The <see cref="T:System.Span`1"/> to be projected</param>
            <param name="span">The output span</param>
            <param name="selector">A selector method that projects <typeparamref name="TIn"/> to <typeparamref name="TOut"/> with the index of the value to project</param>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.SelectToSpan``2(``0[],System.Span{``1},System.Func{``0,``1})">
            <summary>
            Selects the values of a <see cref="T:System.Array"/> to a pre-allocated <see cref="T:System.Span`1"/>.
            </summary>
            <typeparam name="TIn">The input type</typeparam>
            <typeparam name="TOut">The output type</typeparam>
            <param name="list">The <see cref="T:System.Span`1"/> to be projected</param>
            <param name="span">The output span</param>
            <param name="selector">A selector method that projects <typeparamref name="TIn"/> to <typeparamref name="TOut"/></param>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.WhereToSpan``1(System.Span{``0},System.Span{``0},System.Func{``0,System.Boolean})">
            <summary>
            Filters the values of a <see cref="T:System.Span`1"/> to a pre-allocated <see cref="T:System.Span`1"/>.
            </summary>
            <typeparam name="TValue">The type of values to filter</typeparam>
            <param name="span">The <see cref="T:System.Span`1"/> to be projected</param>
            <param name="target">The output span</param>
            <param name="predicate">A predicate to filter the values</param>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.SelectToMemory``2(System.Span{``0},System.Func{``0,``1})">
            <summary>
            Selects the values of a <see cref="T:System.Span`1"/> to a new <see cref="T:System.Memory`1"/>.
            </summary>
            <typeparam name="TIn">The input type</typeparam>
            <typeparam name="TOut">The output type</typeparam>
            <param name="list">The <see cref="T:System.Span`1"/> to be projected</param>
            <param name="span">The output span</param>
            <param name="selector">A selector method that projects <typeparamref name="TIn"/> to <typeparamref name="TOut"/></param>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.SelectToMemory``2(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
            <summary>
            Selects the values of a <see cref="T:System.Collections.Generic.IList`1"/> to a new <see cref="T:System.Memory`1"/>.
            </summary>
            <typeparam name="TIn">The input type</typeparam>
            <typeparam name="TOut">The output type</typeparam>
            <param name="list">The <see cref="T:System.Span`1"/> to be projected</param>
            <param name="span">The output span</param>
            <param name="selector">A selector method that projects <typeparamref name="TIn"/> to <typeparamref name="TOut"/></param>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.WhereToMemory``1(System.Span{``0},System.Func{``0,System.Boolean})">
            <summary>
            Filters the values of a <see cref="T:System.Span`1"/> to a new <see cref="T:System.Memory`1"/>.
            </summary>
            <typeparam name="TValue">The type of values to filter</typeparam>
            <param name="span">The <see cref="T:System.Span`1"/> to be projected</param>
            <param name="predicate">A predicate to filter the values</param>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.WhereToMemory``1(System.Span{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Filters the values of a <see cref="T:System.Span`1"/> to a new <see cref="T:System.Memory`1"/>.
            </summary>
            <typeparam name="TValue">The type of values to filter</typeparam>
            <param name="span">The <see cref="T:System.Span`1"/> to be projected</param>
            <param name="predicate">A predicate to filter the values with the index of the value to filter</param>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.WhereToMemory``2(System.Span{``0},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>
            Filters the values of a <see cref="T:System.Span`1"/>, then projects the values to a new <see cref="T:System.Memory`1"/>.
            </summary>
            <typeparam name="TValue">The type of values to filter</typeparam>
            <param name="span">The <see cref="T:System.Span`1"/> to be projected</param>
            <param name="predicate">A predicate to filter the values with the index of the value to filter</param>
            <param name="selector">A selector method that projects <typeparamref name="TValue"/> to <typeparamref name="TResult"/></param>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.Count``1(System.Span{``0},System.Func{``0,System.Boolean})">
            <summary>
            Provides a Count of values given a predicate
            </summary>
            <typeparam name="T">The type of the values</typeparam>
            <param name="span">The span to count the values in</param>
            <param name="predicate">The predicate to filter the values</param>
            <returns>The count of values</returns>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.Any``1(System.Span{``0},System.Func{``0,System.Boolean})">
            <summary>
            Determines if the provided span contains values given a predicate
            </summary>
            <typeparam name="T">The type of the values</typeparam>
            <param name="span">The span to analyze</param>
            <param name="predicate">The predicate to filter the values</param>
            <returns><c>true</c> if the predicate returned true, otherwise <c>false</c></returns>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.ToDictionary``3(System.Span{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Creates a new <see cref="T:System.Collections.Generic.Dictionary`2"/> from the values of a span.
            </summary>
            <param name="span">The input span</param>
            <param name="keySelector">The selector to create a key of the dictionary</param>
            <param name="valueSelector">The selector to create the value with the corresponding key</param>
            <returns>A new <see cref="T:System.Collections.Generic.Dictionary`2"/></returns>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.Sum(System.Span{System.Double})">
            <summary>
            Computes the sum of all the values of a <see cref="T:System.Span`1"/> where <c>T</c> is a double
            </summary>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.Sum``1(System.Span{``0},System.Func{``0,System.Double})">
            <summary>
            Computes the sum of all the values of a <see cref="T:System.Span`1"/>, using a predicate to get each value.
            </summary>
            <typeparam name="TIn"></typeparam>
            <param name="span">The span to use</param>
            <param name="selector">A selector to get the value</param>
            <returns>The sum of all the projected values</returns>
        </member>
        <member name="M:Uno.Collections.MemoryExtensions.SliceClamped``1(System.Span{``0},System.Int32,System.Int32)">
            <summary>
            Creates a slice for which the <paramref name="start"/> and <paramref name="range"/> are clamped to the size of <paramref name="span"/>.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="span">The span to slice</param>
            <param name="start">The starting index</param>
            <param name="range">The length of the slice</param>
            <returns>A slice of the source span</returns>
        </member>
        <member name="T:Uno.Collections.UnsafeWeakAttachedDictionary`2">
            <summary>
            A dictionary of values that live as long as the owner is alive. This class is not-threadsafe and must always be used for the same thread.
            </summary>
            <typeparam name="TOwner">The type of the owner</typeparam>
            <typeparam name="TKey">The key type</typeparam>
        </member>
        <member name="M:Uno.Collections.UnsafeWeakAttachedDictionary`2.GetValue``1(`0,`1,System.Func{``0})">
            <summary>
            Gets the value associated with the specified key, for the specified owner instance.
            </summary>
            <param name="owner">The owner instance for the specified key</param>
            <param name="key">The key to get</param>
            <param name="defaultSelector">The selector called when the value does not exist for the specified owner. Otherwise, default(TValue) is used.</param>
            <returns>The value</returns>
        </member>
        <member name="M:Uno.Collections.UnsafeWeakAttachedDictionary`2.SetValue``1(`0,`1,``0)">
            <summary>
            Sets the value for the specified key, for the specified owner.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="owner"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Uno.Collections.UnsafeWeakAttachedDictionary`2.GetValuesForOwner(`0)">
            <summary>
            Get the values dictionary for the specified owner
            </summary>
            <param name="owner">The owner of the values</param>
            <returns>A values dictionary</returns>
        </member>
        <member name="M:Uno.Collections.UnsafeWeakAttachedDictionary`2.CopyValues(`0,`0)">
            <summary>
            Copies all values from one owner to another.
            </summary>
            <param name="existingOwner">The <typeparamref name="TOwner"/> to take values from.</param>
            <param name="newOwner">The <typeparamref name="TOwner"/> to assign values to.</param>
        </member>
        <member name="T:Uno.Collections.WeakAttachedDictionary`2">
            <summary>
            A dictionary of values that live as long as the owner is alive. This class is thread-safe.
            </summary>
            <typeparam name="TOwner">The type of the owner</typeparam>
            <typeparam name="TKey">The key type</typeparam>
        </member>
        <member name="M:Uno.Collections.WeakAttachedDictionary`2.GetValue``1(`0,`1,System.Func{``0})">
            <summary>
            Gets the value associated with the specified key, for the specified owner instance.
            </summary>
            <param name="owner">The owner instance for the specified key</param>
            <param name="key">The key to get</param>
            <param name="defaultSelector">The selector called when the value does not exist for the specified owner. Otherwise, default(TValue) is used.</param>
            <returns>The value</returns>
        </member>
        <member name="M:Uno.Collections.WeakAttachedDictionary`2.GetValue``1(`0,`1,System.Func{`1,``0})">
            <summary>
            Gets the value associated with the specified key, for the specified owner instance.
            </summary>
            <param name="owner">The owner instance for the specified key</param>
            <param name="key">The key to get</param>
            <param name="defaultSelector">The selector called when the value does not exist for the specified owner. Otherwise, default(TValue) is used.</param>
            <returns>The value</returns>
        </member>
        <member name="M:Uno.Collections.WeakAttachedDictionary`2.SetValue``1(`0,`1,``0)">
            <summary>
            Sets the value for the specified key, for the specified owner.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="owner"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Uno.Collections.WeakAttachedDictionary`2.CopyValues(`0,`0)">
            <summary>
            Copies all values from one owner to another.
            </summary>
            <param name="existingOwner">The <typeparamref name="TOwner"/> to take values from.</param>
            <param name="newOwner">The <typeparamref name="TOwner"/> to assign values to.</param>
        </member>
        <member name="T:Uno.Core.Comparison.FastTypeComparer">
            <summary>
            A fast type comparer for dictionaries, to avoid going through object.Equals type checking. 
            To be used along with <see cref="T:System.Collections.Generic.Dictionary`2"/> when <see cref="T:System.Type"/> is the key.
            </summary>
        </member>
        <member name="P:Uno.Core.Comparison.FastTypeComparer.Default">
            <summary>
            Provides a single instance
            </summary>
        </member>
        <member name="T:Uno.Core.DisposableConditionalWeakTable`2">
            <summary>Enables compilers to dynamically attach IDisposable fields to managed objects. Attached disposable will be disposed on when the key object is collected.</summary>
            <typeparam name="TKey">The reference type to which the field is attached. </typeparam>
            <typeparam name="TValue">The field's type. This must be a reference type.</typeparam>
        </member>
        <member name="M:Uno.Core.DisposableConditionalWeakTable`2.Add(`0,`1)">
            <summary>Adds a key to the table.</summary>
            <param name="key">The key to add. <paramref name="key" /> represents the object to which the property is attached.</param>
            <param name="value">The key's property value.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key" /> is null.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="key" /> already exists.</exception>
        </member>
        <member name="M:Uno.Core.DisposableConditionalWeakTable`2.GetOrCreateValue(`0)">
            <summary>Atomically searches for a specified key in the table and returns the corresponding value. If the key does not exist in the table, the method invokes the default constructor of the class that represents the table's value to create a value that is bound to the specified key. </summary>
            <returns>The value that corresponds to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, a new value created by the default constructor of the class defined by the TValue generic type parameter.</returns>
            <param name="key">The key to search for. <paramref name="key" /> represents the object to which the property is attached.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key" /> is null.</exception>
            <exception cref="T:System.MissingMethodException">In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception, <see cref="T:System.MissingMemberException" />, instead.The class that represents the table's value does not define a default constructor.</exception>
        </member>
        <member name="M:Uno.Core.DisposableConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)">
            <summary>Atomically searches for a specified key in the table and returns the corresponding value. If the key does not exist in the table, the method invokes a callback method to create a value that is bound to the specified key.</summary>
            <returns>The value attached to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, the new value returned by the <paramref name="createValueCallback" /> delegate.</returns>
            <param name="key">The key to search for. <paramref name="key" /> represents the object to which the property is attached.</param>
            <param name="createValueCallback">A delegate to a method that can create a value for the given <paramref name="key" />. It has a single parameter of type TKey, and returns a value of type TValue.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key" /> or <paramref name="createValueCallback" /> is null.</exception>
        </member>
        <member name="M:Uno.Core.DisposableConditionalWeakTable`2.Remove(`0)">
            <summary>Removes a key and its value from the table.</summary>
            <returns>true if the key is found and removed; otherwise, false.</returns>
            <param name="key">The key to remove. </param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key" /> is null.</exception>
        </member>
        <member name="M:Uno.Core.DisposableConditionalWeakTable`2.TryGetValue(`0,`1@)">
            <summary>Gets the value of the specified key.</summary>
            <returns>true if <paramref name="key" /> is found; otherwise, false.</returns>
            <param name="key">The key that represents an object with an attached property.</param>
            <param name="value">When this method returns, contains the attached property value. If <paramref name="key" /> is not found, <paramref name="value" /> contains the default value.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key" /> is null.</exception>
        </member>
        <member name="M:Uno.Core.Equality.EqualityComparerExtensions.ToEqualityComparer``1(System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Create a non-generic <see cref="T:System.Collections.IEqualityComparer"/> from a generic version.
            </summary>
        </member>
        <member name="T:Uno.Comparison.FuncComparer`1">
            <summary>
            An <see cref="T:System.Collections.Generic.IComparer`1"/> configurable using Funcs
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Uno.Comparison.FuncComparer`1.Create``1(System.Func{`0,``0})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IComparer`1"/> using a value selector.
            </summary>
        </member>
        <member name="M:Uno.Comparison.FuncComparer`1.#ctor(System.Func{`0,`0,System.Int32})">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:Uno.Comparison.FuncComparer`1.Compare(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="T:Uno.CompositionType">
            <summary>
            Represets the type of composition.
            </summary>
        </member>
        <member name="T:Uno.Conversion.EnumConversionStrategy">
            <summary>
            Will convert to and from enum, usually with strings
            </summary>
            <remarks>
            System.ComponentModel.DescriptionAttribute is can be used as result
            or parsing value, if not empty.
            A description attribute with "?" is considered default value.
            </remarks>
        </member>
        <member name="M:Uno.Conversion.IConversionExtensions.Conversion(System.Object)">
            <summary>
            Create extension point (prefer the usage of method extensions)
            </summary>
        </member>
        <member name="M:Uno.Conversion.IConversionExtensions.RegisterStrategy(Uno.Conversion.IConversionStrategy)">
            <summary>
            Register a conversion strategy
            </summary>
        </member>
        <member name="M:Uno.Conversion.IConversionExtensions.RegisterFallbackStrategy(Uno.Conversion.IConversionStrategy)">
            <summary>
            Register a conversion strategy to be used as fallback
            </summary>
        </member>
        <member name="M:Uno.Conversion.IConversionExtensions.CanConvert(Uno.Conversion.ConversionExtensionPoint,System.Object,System.Type,System.Globalization.CultureInfo)">
            <summary>
            Check if it's possible to do a conversion
            </summary>
        </member>
        <member name="M:Uno.Conversion.IConversionExtensions.To(Uno.Conversion.ConversionExtensionPoint,System.Type,System.Globalization.CultureInfo)">
            <summary>
            Initiate the conversion
            </summary>
            <remarks>
            This method is usually called by the extension point.
            </remarks>
            <returns>Conversion result</returns>
        </member>
        <member name="M:Uno.Conversion.ConversionExtensionsExtensions.RegisterStrategy``1(Uno.Conversion.IConversionExtensions)">
            <summary>
            Fluently register a conversion strategy
            </summary>
        </member>
        <member name="M:Uno.Conversion.ConversionExtensionsExtensions.RegisterCustomStrategy``2(Uno.Conversion.IConversionExtensions,System.Func{``0,System.Globalization.CultureInfo,``1})">
            <summary>
            Fluently register a custom conversion strategy
            </summary>
        </member>
        <member name="M:Uno.Conversion.ConversionExtensionsExtensions.RegisterCustomStrategy``2(Uno.Conversion.IConversionExtensions,System.Func{``0,``1})">
            <summary>
            Fluently register a custom conversion strategy
            </summary>
        </member>
        <member name="M:Uno.Conversion.ConversionExtensionsExtensions.RegisterFallbackStrategy``1(Uno.Conversion.IConversionExtensions)">
            <summary>
            Fluently register a conversion strategy to be used as fallback
            </summary>
        </member>
        <member name="M:Uno.Conversion.ConversionExtensionsExtensions.To``1(Uno.Conversion.IConversionExtensions,Uno.Conversion.ConversionExtensionPoint,System.Globalization.CultureInfo)">
            <summary>
            Convert source to a specified generic type
            </summary>
            <returns>Conversion result</returns>
        </member>
        <member name="M:Uno.Conversion.IConversionStrategy.CanConvert(System.Object,System.Type,System.Globalization.CultureInfo)">
            <summary>
            If the strategy can support a specific value as input
            </summary>
            <returns>true=supported</returns>
        </member>
        <member name="M:Uno.Conversion.IConversionStrategy.Convert(System.Object,System.Type,System.Globalization.CultureInfo)">
            <summary>
            Issue the conversion result
            </summary>
            <returns>result</returns>
        </member>
        <member name="T:Uno.Decorator.Decorator`1">
            <summary>
            A implementation of IDecorator.
            </summary>
            <typeparam name="T">The type to decorate.</typeparam>
        </member>
        <member name="M:Uno.Decorator.Decorator`1.#ctor">
            <summary>
            Constructs a new Decorator for a default(T) target.
            </summary>
        </member>
        <member name="M:Uno.Decorator.Decorator`1.#ctor(`0)">
            <summary>
            Constructs a new Decorator for a specified target.
            </summary>
            <param name="target">The target.</param>
        </member>
        <member name="P:Uno.Decorator.Decorator`1.Target">
            <summary>
            See base.
            </summary>
        </member>
        <member name="T:Uno.Decorator.IDecorator`1">
            <summary>
            The interface for the interface Decorator pattern.
            </summary>
            <typeparam name="T">The type to decorate.</typeparam>
        </member>
        <member name="P:Uno.Decorator.IDecorator`1.Target">
            <summary>
            An accessor for the target T.
            </summary>
        </member>
        <member name="T:Uno.DelegateConditionalWeakTable`1">
            <summary>
            A <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2"/> dedicated to delegates.
            <remarks>
            This helps to attach values to a delegate, but be aware that you may have **lots** of instances of the _same_ delegate (i.e. target + method).
            This should be used **only** for performance consideration, and you must assume that you may have multiple attached values 
            for the _same_ delegate.
            </remarks>
            </summary>
            <typeparam name="TValue">The field's type. This must be a reference type.</typeparam>
        </member>
        <member name="M:Uno.DelegateConditionalWeakTable`1.GetValue(System.Delegate,System.Func{System.Delegate,`0})">
            <summary>
            Atomically searches for a specified key in the table and returns the corresponding value. 
            If the key does not exist in the table, the method invokes a callback method to create a value that is bound to the specified key.
            </summary>
            <param name="key">The key to search for. key represents the object to which the property is attached.</param>
            <param name="factory">A delegate to a method that can create a value for the given key. It has a single parameter of type TKey, and returns a value of type TValue.</param>
            <returns>The value attached to key, if key already exists in the table; otherwise, the new value returned by the createValueCallback delegate.</returns>
        </member>
        <member name="M:Uno.DelegateConditionalWeakTable`1.TryGetValue(System.Delegate,`0@)">
            <summary>
            Gets the value of the specified key.
            </summary>
            <param name="key">The key that represents an object with an attached property.</param>
            <param name="value">When this method returns, contains the attached property value. If key is not found, value contains the default value.</param>
            <returns>true if key is found; otherwise, false.</returns>
        </member>
        <member name="M:Uno.DelegateConditionalWeakTable`1.Remove(System.Delegate)">
            <summary>
            Removes a key and its value from the table.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>rue if the key is found and removed; otherwise, false.</returns>
        </member>
        <member name="T:Uno.Disposables.AnonymousDisposable">
            <summary>
            Represents an Action-based disposable.
            </summary>
        </member>
        <member name="M:Uno.Disposables.AnonymousDisposable.#ctor(System.Action)">
            <summary>
            Constructs a new disposable with the given action used for disposal.
            </summary>
            <param name="dispose">Disposal action which will be run upon calling Dispose.</param>
        </member>
        <member name="P:Uno.Disposables.AnonymousDisposable.IsDisposed">
            <summary>
            Gets a value that indicates whether the object is disposed.
            </summary>
        </member>
        <member name="M:Uno.Disposables.AnonymousDisposable.Dispose">
            <summary>
            Calls the disposal action if and only if the current instance hasn't been disposed yet.
            </summary>
        </member>
        <member name="T:Uno.Disposables.CancellationDisposable">
            <summary>
            Represents a disposable resource that has an associated <seealso cref="T:System.Threading.CancellationToken"/> that will be set to the cancellation requested state upon disposal.
            </summary>
        </member>
        <member name="M:Uno.Disposables.CancellationDisposable.#ctor(System.Threading.CancellationTokenSource)">
            <summary>
            Initializes a new instance of the <see cref="T:Uno.Disposables.CancellationDisposable"/> class that uses an existing <seealso cref="T:System.Threading.CancellationTokenSource"/>.
            </summary>
            <param name="cts"><seealso cref="T:System.Threading.CancellationTokenSource"/> used for cancellation.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="cts"/> is null.</exception>
        </member>
        <member name="M:Uno.Disposables.CancellationDisposable.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Uno.Disposables.CancellationDisposable"/> class that uses a new <seealso cref="T:System.Threading.CancellationTokenSource"/>.
            </summary>
        </member>
        <member name="P:Uno.Disposables.CancellationDisposable.Token">
            <summary>
            Gets the <see cref="T:System.Threading.CancellationToken"/> used by this CancellationDisposable.
            </summary>
        </member>
        <member name="M:Uno.Disposables.CancellationDisposable.Dispose">
            <summary>
            Cancels the underlying <seealso cref="T:System.Threading.CancellationTokenSource"/>.
            </summary>
        </member>
        <member name="P:Uno.Disposables.CancellationDisposable.IsDisposed">
            <summary>
            Gets a value that indicates whether the object is disposed.
            </summary>
        </member>
        <member name="T:Uno.Disposables.CompositeDisposable">
            <summary>
            Represents a group of disposable resources that are disposed together.
            </summary>
        </member>
        <member name="M:Uno.Disposables.CompositeDisposable.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Uno.Disposables.CompositeDisposable"/> class with no disposables contained by it initially.
            </summary>
        </member>
        <member name="M:Uno.Disposables.CompositeDisposable.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Uno.Disposables.CompositeDisposable"/> class with the specified number of disposables.
            </summary>
            <param name="capacity">The number of disposables that the new CompositeDisposable can initially store.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> is less than zero.</exception>
        </member>
        <member name="M:Uno.Disposables.CompositeDisposable.#ctor(System.IDisposable[])">
            <summary>
            Initializes a new instance of the <see cref="T:Uno.Disposables.CompositeDisposable"/> class from a group of disposables.
            </summary>
            <param name="disposables">Disposables that will be disposed together.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="disposables"/> is null.</exception>
        </member>
        <member name="M:Uno.Disposables.CompositeDisposable.#ctor(System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>
            Initializes a new instance of the <see cref="T:Uno.Disposables.CompositeDisposable"/> class from a group of disposables.
            </summary>
            <param name="disposables">Disposables that will be disposed together.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="disposables"/> is null.</exception>
        </member>
        <member name="P:Uno.Disposables.CompositeDisposable.Count">
            <summary>
            Gets the number of disposables contained in the CompositeDisposable.
            </summary>
        </member>
        <member name="M:Uno.Disposables.CompositeDisposable.Add(System.IDisposable)">
            <summary>
            Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.
            </summary>
            <param name="item">Disposable to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
        </member>
        <member name="M:Uno.Disposables.CompositeDisposable.Remove(System.IDisposable)">
            <summary>
            Removes and disposes the first occurrence of a disposable from the CompositeDisposable.
            </summary>
            <param name="item">Disposable to remove.</param>
            <returns>true if found; false otherwise.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
        </member>
        <member name="M:Uno.Disposables.CompositeDisposable.Dispose">
            <summary>
            Disposes all disposables in the group and removes them from the group.
            </summary>
        </member>
        <member name="M:Uno.Disposables.CompositeDisposable.Clear">
            <summary>
            Removes and disposes all disposables from the CompositeDisposable, but does not dispose the CompositeDisposable.
            </summary>
        </member>
        <member name="M:Uno.Disposables.CompositeDisposable.Contains(System.IDisposable)">
            <summary>
            Determines whether the CompositeDisposable contains a specific disposable.
            </summary>
            <param name="item">Disposable to search for.</param>
            <returns>true if the disposable was found; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
        </member>
        <member name="M:Uno.Disposables.CompositeDisposable.CopyTo(System.IDisposable[],System.Int32)">
            <summary>
            Copies the disposables contained in the CompositeDisposable to an array, starting at a particular array index.
            </summary>
            <param name="array">Array to copy the contained disposables to.</param>
            <param name="arrayIndex">Target index at which to copy the first disposable of the group.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than zero. -or - <paramref name="arrayIndex"/> is larger than or equal to the array length.</exception>
        </member>
        <member name="P:Uno.Disposables.CompositeDisposable.IsReadOnly">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="M:Uno.Disposables.CompositeDisposable.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the CompositeDisposable.
            </summary>
            <returns>An enumerator to iterate over the disposables.</returns>
        </member>
        <member name="M:Uno.Disposables.CompositeDisposable.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the CompositeDisposable.
            </summary>
            <returns>An enumerator to iterate over the disposables.</returns>
        </member>
        <member name="P:Uno.Disposables.CompositeDisposable.IsDisposed">
            <summary>
            Gets a value that indicates whether the object is disposed.
            </summary>
        </member>
        <member name="M:Uno.Disposables.CompositeDisposableExtensions.Add(Uno.Disposables.CompositeDisposable,System.Action)">
            <summary>
            Adds an action to be executed when the CompositeDisposable is disposed.
            </summary>
            <param name="disposable">The composite disposable instance</param>
            <param name="action">The action to execute</param>
            <returns>The source composite disposable</returns>
        </member>
        <member name="T:Uno.Disposables.ConditionalDisposable">
            <summary>
            A disposable that can call an action when a dependent object has been collected.
            </summary>
        </member>
        <member name="M:Uno.Disposables.ConditionalDisposable.#ctor(System.Object,System.Action,System.WeakReference)">
            <summary>
            Creates a <see cref="T:Uno.Disposables.ConditionalDisposable"/> instance using 
            <paramref name="target"/> as a reference for its lifetime.
            </summary>
            <param name="action">The action to be executed when target has been collected</param>
            <param name="conditionSource">An optional secondary reference, used to avoid calling action if it has been collected</param>
            <param name="target">The instance to use to keep the disposable alive</param>
        </member>
        <member name="T:Uno.Disposables.DefaultDisposable">
            <summary>
            Represents a disposable that does nothing on disposal.
            </summary>
        </member>
        <member name="F:Uno.Disposables.DefaultDisposable.Instance">
            <summary>
            Singleton default disposable.
            </summary>
        </member>
        <member name="M:Uno.Disposables.DefaultDisposable.Dispose">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="T:Uno.Disposables.Disposable">
            <summary>
            Provides a set of static methods for creating Disposables.
            </summary>
        </member>
        <member name="P:Uno.Disposables.Disposable.Empty">
            <summary>
            Gets the disposable that does nothing when disposed.
            </summary>
        </member>
        <member name="M:Uno.Disposables.Disposable.Create(System.Action)">
            <summary>
            Creates a disposable object that invokes the specified action when disposed.
            </summary>
            <param name="dispose">Action to run during the first call to <see cref="M:System.IDisposable.Dispose"/>. The action is guaranteed to be run at most once.</param>
            <returns>The disposable object that runs the given action upon disposal.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dispose"/> is null.</exception>
        </member>
        <member name="M:Uno.Disposables.DisposableExtensions.DisposeWith``1(``0,System.Collections.Generic.ICollection{System.IDisposable})">
            <summary>
            Register an object who implements IDisposable to be disposed by a CompositeDisposable.
            </summary>
            <remarks>
            The parameter could be anything who implements ICollection&lt;IDisposable&gt;.
            This extension is designed for usage in a fluent declaration.
            </remarks>
        </member>
        <member name="M:Uno.Disposables.DisposableExtensions.DisposeWith``1(``0,Uno.Disposables.SerialDisposable)">
            <summary>
            Register an object who implements IDisposable to be disposed by a SerialDisposable.
            </summary>
            <remarks>
            This extension is designed for usage in a fluent declaration.
            </remarks>
        </member>
        <member name="M:Uno.Disposables.DisposableExtensions.SafeDispose(System.IDisposable)">
            <summary>
            Dispose the object if not null
            </summary>
        </member>
        <member name="M:Uno.Disposables.DisposableExtensions.TryDispose(System.Object)">
            <summary>
            Dispose the object if not null and if it implements IDisposable
            </summary>
            <returns>
            True means the object was successfully disposed.
            </returns>
        </member>
        <member name="M:Uno.Disposables.DisposableExtensions.DisposeOrLog(System.IDisposable,System.String)">
            <summary>
            Dispose the dispoable, and if an error is raised log it
            </summary>
        </member>
        <member name="M:Uno.Disposables.DisposableExtensions.DisposeAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Dispose all items of an enumerable sequence
            <remarks>IF one dispose fails, continue other an raise a single Aggregate exception</remarks>
            </summary>
            <exception cref="T:System.AggregateException">Raised if any dispose fails</exception>
        </member>
        <member name="M:Uno.Disposables.DisposableExtensions.DisposeAllOrLog``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Diuspose all items of an enumerable sequence, and if any failed log it and continue
            </summary>
        </member>
        <member name="T:Uno.Disposables.ICancelable">
            <summary>
            Disposable resource with dipsosal state tracking.
            </summary>
        </member>
        <member name="P:Uno.Disposables.ICancelable.IsDisposed">
            <summary>
            Gets a value that indicates whether the object is disposed.
            </summary>
        </member>
        <member name="T:Uno.Disposables.IExtensibleDisposable">
            <summary>
            Represents a disposable object on which some external disposables can be linked to, in order to share its lifetime.
            <remarks>
            Default implementation:<br />
            <br />
            private readonly CompositeDisposable _subscriptions = new CompositeDisposable();<br />
            public IDisposable RegisterExtension(IDisposable disposable) => _subscriptions.DisposableAdd(disposable);<br />
            public void Dispose() => _subscriptions.Dispose();
            </remarks>
            </summary>
        </member>
        <member name="P:Uno.Disposables.IExtensibleDisposable.Extensions">
            <summary>
            Currently registered extensions
            </summary>
            <remarks>
            To get a known service, use Extensions.<see cref="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)"/>.
            </remarks>
        </member>
        <member name="M:Uno.Disposables.IExtensibleDisposable.RegisterExtension``1(``0)">
            <summary>
            Registers an extension and links its lifetime (disposal) with the lifetime of the extended disposable
            </summary>
            <remarks>
            The extension will be disposed with the extended disposable or when it's unregistered.
            To unregister, dispose the returned disposable.  You can discard the
            returned disposable if you're not planning to unregister the extension.
            </remarks>
        </member>
        <member name="T:Uno.Disposables.RefCountDisposable">
            <summary>
            Represents a disposable resource that only disposes its underlying disposable resource when all <see cref="M:Uno.Disposables.RefCountDisposable.GetDisposable">dependent disposable objects</see> have been disposed.
            </summary>
        </member>
        <member name="F:Uno.Disposables.RefCountDisposable._count">
            <summary>
            Holds the number of active child disposables and the
            indicator bit (31) if the main _disposable has been marked
            for disposition.
            </summary>
        </member>
        <member name="M:Uno.Disposables.RefCountDisposable.#ctor(System.IDisposable)">
            <summary>
            Initializes a new instance of the <see cref="T:Uno.Disposables.RefCountDisposable"/> class with the specified disposable.
            </summary>
            <param name="disposable">Underlying disposable.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="disposable"/> is null.</exception>
        </member>
        <member name="M:Uno.Disposables.RefCountDisposable.#ctor(System.IDisposable,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Uno.Disposables.RefCountDisposable"/> class with the specified disposable.
            </summary>
            <param name="disposable">Underlying disposable.</param>
            <param name="throwWhenDisposed">Indicates whether subsequent calls to <see cref="M:Uno.Disposables.RefCountDisposable.GetDisposable"/> should throw when this instance is disposed.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="disposable"/> is null.</exception>
        </member>
        <member name="P:Uno.Disposables.RefCountDisposable.IsDisposed">
            <summary>
            Gets a value that indicates whether the object is disposed.
            </summary>
        </member>
        <member name="M:Uno.Disposables.RefCountDisposable.GetDisposable">
            <summary>
            Returns a dependent disposable that when disposed decreases the refcount on the underlying disposable.
            </summary>
            <returns>A dependent disposable contributing to the reference count that manages the underlying disposable's lifetime.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed and is configured to throw in this case by <see cref="M:Uno.Disposables.RefCountDisposable.#ctor(System.IDisposable,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Uno.Disposables.RefCountDisposable.Dispose">
            <summary>
            Disposes the underlying disposable only when all dependent disposables have been disposed.
            </summary>
        </member>
        <member name="T:Uno.Disposables.SerialDisposable">
            <summary>
            Represents a disposable resource whose underlying disposable resource can be replaced by another disposable resource, causing automatic disposal of the previous underlying disposable resource.
            </summary>
        </member>
        <member name="M:Uno.Disposables.SerialDisposable.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Uno.Disposables.SerialDisposable"/> class.
            </summary>
        </member>
        <member name="P:Uno.Disposables.SerialDisposable.IsDisposed">
            <summary>
            Gets a value that indicates whether the object is disposed.
            </summary>
        </member>
        <member name="P:Uno.Disposables.SerialDisposable.Disposable">
            <summary>
            Gets or sets the underlying disposable.
            </summary>
            <remarks>If the SerialDisposable has already been disposed, assignment to this property causes immediate disposal of the given disposable object. Assigning this property disposes the previous disposable object.</remarks>
        </member>
        <member name="M:Uno.Disposables.SerialDisposable.Dispose">
            <summary>
            Disposes the underlying disposable as well as all future replacements.
            </summary>
        </member>
        <member name="M:Uno.EnumUtilities.Parse(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            Converts the string representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object.
            </summary>
            <param name="enumType">An enumeration type.</param>
            <param name="value">A string containing the name or value to convert.</param>
            <param name="ignoreCase">true to ignore case; false to regard case.</param>
            <param name="useFallbackValue">If true and parsing failed, try to find the value which has the <seealso cref="T:Uno.FallbackValueAttribute"/> and send it back.</param>
            <returns>An object of type enumType whose value is represented by value.</returns>
        </member>
        <member name="T:Uno.Equality.CollectionEqualityComparer`1">
            <summary>
            An EqualityComparre which compare sequence of items
            </summary>
        </member>
        <member name="M:Uno.Equality.CollectionEqualityComparer`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            ctor
            </summary>
            <param name="comparer">Comparer to use to compare each item</param>
        </member>
        <member name="M:Uno.Equality.CollectionEqualityComparer`1.Equals(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Uno.Equality.CollectionEqualityComparer`1.GetHashCode(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="T:Uno.Equality.FuncEqualityComparer">
            <summary>
            Allows <see cref="T:Uno.Equality.FuncEqualityComparer`1"/> methods to be called without specifying the compared 
            type explicitely, which simplifies the syntax and allows for equality comparisons on anonymous types
            </summary>
        </member>
        <member name="M:Uno.Equality.FuncEqualityComparer.Create``2(System.Func{``0,``1})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which determine objects equality and hash codes based on a value obtained using a selector.
            </summary>
            <param name="valueSelector">Selector to get the value used for comparison of objects.</param>
            <typeparam name="TValue">Type of the value to compare.</typeparam>
        </member>
        <member name="M:Uno.Equality.FuncEqualityComparer.Create``2(System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which determine objects equality and hash codes based on a value obtained using a selector.
            </summary>
            <param name="valueSelector">Selector to get the value used for comparison of objects.</param>
            <param name="valueEqualityComparer">Equlity comparre to use to comprer the selectd values.</param>
            <typeparam name="TValue">Type of the value to compare.</typeparam>
        </member>
        <member name="T:Uno.Equality.FuncEqualityComparer`1">
            <summary>
            An EqualityComparer configurable using Funcs.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
        </member>
        <member name="M:Uno.Equality.FuncEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean})">
            <summary>
            DO NOT USE
            </summary>
            <remarks>This constructor does not provide a way to correctly implements the <see cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)"/>. Prefer use overload with the GetHashCode</remarks>
            <param name="predicate"></param>
        </member>
        <member name="M:Uno.Equality.FuncEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})">
            <summary>
            .ctor
            </summary>
            <param name="equals">Predicate to invoke to determine equality between objects.</param>
            <param name="getHashCode">Predicate to invoke to get the hash code of an object.</param>
        </member>
        <member name="M:Uno.Equality.FuncEqualityComparer`1.Create``1(System.Func{`0,``0})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which determine objects equality and hash codes based on a value obtained using a selector.
            </summary>
            <param name="valueSelector">Selector to get the value used for comparison of objects.</param>
            <typeparam name="TValue">Type of the value to compare.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Uno.Equality.FuncEqualityComparer`1.Create``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which determine objects equality and hash codes based on a value obtained using a selector.
            </summary>
            <param name="valueSelector">Selector to get the value used for comparison of objects.</param>
            <param name="valueEqualityComparer">Equlity comparre to use to comprer the selectd values.</param>
            <typeparam name="TValue">Type of the value to compare.</typeparam>
            <returns></returns>
        </member>
        <member name="T:Uno.Equality.FuncEqualityComparer`2">
            <summary>
            An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which determine objects equality and hash codes based on a value obtained using a selector.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
            <typeparam name="TValue">The type of the value used for comparison.</typeparam>
        </member>
        <member name="M:Uno.Equality.FuncEqualityComparer`2.#ctor(System.Func{`0,`1},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            .ctor
            </summary>
            <param name="valueSelector">Selector to get the value used for comparison of objects.</param>
        </member>
        <member name="T:Uno.Equality.IKeyEquatable">
            <summary>
            Defines a generalized method that a value type or class implements to create a type-specific method for determining equality of version of instances.
            </summary>
        </member>
        <member name="M:Uno.Equality.IKeyEquatable.GetKeyHashCode">
            <summary>
            Gets the hash code of the key of this object.
            </summary>
            <returns>A hash code for the current object's key.</returns>
        </member>
        <member name="M:Uno.Equality.IKeyEquatable.KeyEquals(System.Object)">
            <summary>
            Indicates whether the key of current object is equal to another object's key of the same type.
            </summary>
            <param name="other">The object to compare with this object.</param>
            <returns>True is the current object is another version of the <paramref name="other"/> parameter; otherwise false</returns>
        </member>
        <member name="T:Uno.Equality.IKeyEquatable`1">
            <summary>
            Defines a generalized method that a value type or class implements to create a type-specific method for determining equality of version of instances.
            </summary>
        </member>
        <member name="M:Uno.Equality.IKeyEquatable`1.GetKeyHashCode">
            <summary>
            Gets the hash code of the key of this object.
            </summary>
            <returns>A hash code for the current object's key.</returns>
        </member>
        <member name="M:Uno.Equality.IKeyEquatable`1.KeyEquals(`0)">
            <summary>
            Indicates whether the key of current object is equal to another object's key of the same type.
            </summary>
            <param name="other">The object to compare with this object.</param>
            <returns>True is the current object is another version of the <paramref name="other"/> parameter; otherwise false</returns>
        </member>
        <member name="T:Uno.Equality.KeyEqualityComparer">
            <summary>
            An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which compares the key of the objects.
            </summary>
            <remarks>
            For this comparer, the compared objects MUST IMPLEMENT <see cref="T:Uno.Equality.IKeyEquatable"/> (the non-generic version)
            i.e. **not <see cref="T:Uno.Equality.IKeyEquatable`1"/>**
            </remarks>
        </member>
        <member name="P:Uno.Equality.KeyEqualityComparer.Default">
            <summary>
            Gets the default instance of the <see cref="T:Uno.Equality.KeyEqualityComparer"/>.
            </summary>
        </member>
        <member name="T:Uno.Equality.KeyEqualityComparer`1">
            <summary>
            An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which compares the key of the objects.
            </summary>
            <typeparam name="T">Type of the object to compare</typeparam>
        </member>
        <member name="P:Uno.Equality.KeyEqualityComparer`1.Default">
            <summary>
            Gets the default instance of the <see cref="T:Uno.Equality.KeyEqualityComparer`1"/>.
            </summary>
        </member>
        <member name="M:Uno.Equality.KeyEqualityComparer`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:Uno.Equality.KeyEqualityComparer`1.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="T:Uno.Events.EventHandlerConverter`2">
            <summary>
            A helper to convert the type of an event handler and manage the subscriptions.
            </summary>
            <typeparam name="TFromHandler">The source handler</typeparam>
            <typeparam name="TToHandler">The target handler</typeparam>
        </member>
        <member name="M:Uno.Events.EventHandlerConverter`2.Add(`0)">
            <summary>
            Subscribe to the inner event
            </summary>
        </member>
        <member name="M:Uno.Events.EventHandlerConverter`2.Remove(`0)">
            <summary>
            Unsubscribe from the inner event
            </summary>
        </member>
        <member name="M:Uno.Funcs.Create``1(System.Func{``0})">
            <summary>
            Creates a function, to allow for type inference from the returned value.
            </summary>
            <typeparam name="TResult">The returned type</typeparam>
            <param name="function">The source function</param>
            <returns>A function</returns>
        </member>
        <member name="M:Uno.Funcs.Create``2(System.Func{``0,``1})">
            <summary>
            Creates a function, to allow for type inference from the returned value.
            </summary>
            <typeparam name="TResult">The returned type</typeparam>
            <param name="function">The source function</param>
            <returns>A function</returns>
        </member>
        <member name="M:Uno.Funcs.Create``3(System.Func{``0,``1,``2})">
            <summary>
            Creates a function, to allow for type inference from the returned value.
            </summary>
            <typeparam name="TResult">The returned type</typeparam>
            <param name="function">The source function</param>
            <returns>A function</returns>
        </member>
        <member name="M:Uno.Funcs.Create``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Creates a function, to allow for type inference from the returned value.
            </summary>
            <typeparam name="TResult">The returned type</typeparam>
            <param name="function">The source function</param>
            <returns>A function</returns>
        </member>
        <member name="M:Uno.Funcs.CreateAsync``1(Uno.FuncAsync{``0})">
            <summary>
            Creates a parameterless cancellable async function.
            </summary>
            <typeparam name="TResult">The returned type</typeparam>
            <param name="function">The source function</param>
            <returns>A function</returns>
        </member>
        <member name="M:Uno.Funcs.CreateAsync``2(Uno.FuncAsync{``0,``1})">
            <summary>
            Creates a parameterized cancellable async function.
            </summary>
            <typeparam name="TResult">The returned type</typeparam>
            <param name="function">The source function</param>
            <returns>A function</returns>
        </member>
        <member name="M:Uno.Funcs.CreateAsync``3(Uno.FuncAsync{``0,``1,``2})">
            <summary>
            Creates a parameterized cancellable async function.
            </summary>
            <typeparam name="TResult">The returned type</typeparam>
            <param name="function">The source function</param>
            <returns>A function</returns>
        </member>
        <member name="M:Uno.Funcs.CreateAsync``4(Uno.FuncAsync{``0,``1,``2,``3})">
            <summary>
            Creates a parameterized cancellable async function.
            </summary>
            <typeparam name="TResult">The returned type</typeparam>
            <param name="function">The source function</param>
            <returns>A function</returns>
        </member>
        <member name="M:Uno.Funcs.Create``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})">
            <summary>
            Creates a parameterless cancellable async function.
            </summary>
            <typeparam name="TResult">The return value</typeparam>
            <param name="function">The source function</param>
            <returns>A func of the source</returns>
        </member>
        <member name="M:Uno.Funcs.Create``2(System.Func{System.Threading.CancellationToken,``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Creates a parameterized cancellable async function.
            </summary>
            <typeparam name="TResult">The return value</typeparam>
            <param name="function">The source function</param>
            <returns>A func of the source</returns>
        </member>
        <member name="M:Uno.Funcs.CreateMemoized``1(System.Func{``0})">
            <summary>
            Creates a parameterless memoized function. <seealso cref="T:Uno.Extensions.FuncMemoizeExtensions"/>
            </summary>
            <typeparam name="TResult">The returned type</typeparam>
            <param name="function">The source function</param>
            <returns>A function</returns>
        </member>
        <member name="M:Uno.Funcs.CreateLockedMemoized``1(System.Func{``0})">
            <summary>
            Creates a parameterless thread-safe memoized function. <seealso cref="T:Uno.Extensions.FuncMemoizeExtensions"/>
            </summary>
            <typeparam name="TResult">The returned type</typeparam>
            <param name="function">The source function</param>
            <returns>A function</returns>
        </member>
        <member name="M:Uno.Funcs.CreateMemoized``2(System.Func{``0,``1})">
            <summary>
            Creates a parameterized memoized function.
            </summary>
            <typeparam name="TParam">The parameter</typeparam>
            <typeparam name="TResult">The return value</typeparam>
            <param name="function">The function to memoize</param>
            <returns>The memoized function</returns>
        </member>
        <member name="M:Uno.Funcs.CreateMemoized``3(System.Func{``0,``1,``2})">
            <summary>
            Creates a parameterized memoized function.
            </summary>
            <typeparam name="TParam1">The first parameter</typeparam>
            <typeparam name="TParam2">The second parameter</typeparam>
            <typeparam name="TResult">The return value</typeparam>
            <param name="function">The function to memoize</param>
            <returns>The memoized function</returns>
        </member>
        <member name="M:Uno.Funcs.CreateMemoized``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Creates a parameterized memoized function.
            </summary>
            <typeparam name="TParam1">The first parameter</typeparam>
            <typeparam name="TParam2">The second parameter</typeparam>
            <typeparam name="TParam3">The third parameter</typeparam>
            <typeparam name="TResult">The return value</typeparam>
            <param name="function">The function to memoize</param>
            <returns>The memoized function</returns>
        </member>
        <member name="M:Uno.Funcs.CreateMemoized``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Creates a parameterized memoized function.
            </summary>
            <typeparam name="TParam1">The first parameter</typeparam>
            <typeparam name="TParam2">The second parameter</typeparam>
            <typeparam name="TParam3">The third parameter</typeparam>
            <typeparam name="TParam4">The fourth parameter</typeparam>
            <typeparam name="TResult">The return value</typeparam>
            <param name="function">The function to memoize</param>
            <returns>The memoized function</returns>
        </member>
        <member name="M:Uno.Funcs.CreateMemoized``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Creates a parameterized memoized function.
            </summary>
            <typeparam name="TParam1">The first parameter</typeparam>
            <typeparam name="TParam2">The second parameter</typeparam>
            <typeparam name="TParam3">The third parameter</typeparam>
            <typeparam name="TParam4">The fourth parameter</typeparam>
            <typeparam name="TParam5">The fifth parameter</typeparam>
            <typeparam name="TResult">The return value</typeparam>
            <param name="function">The function to memoize</param>
            <returns>The memoized function</returns>
        </member>
        <member name="M:Uno.Funcs.CreateAsyncMemoized``1(Uno.FuncAsync{``0})">
            <summary>
            Creates a parameterless memoized task providing function. <seealso cref="T:Uno.Extensions.FuncMemoizeExtensions"/>
            </summary>
            <typeparam name="TResult">The returned type</typeparam>
            <param name="function">The source function</param>
            <returns>A function</returns>
        </member>
        <member name="M:Uno.Funcs.CreateAsyncMemoized``2(Uno.FuncAsync{``0,``1})">
            <summary>
            Creates a parameterless memoized task providing function. <seealso cref="T:Uno.Extensions.FuncMemoizeExtensions"/>
            </summary>
            <typeparam name="TResult">The returned type</typeparam>
            <param name="function">The source function</param>
            <returns>A function</returns>
        </member>
        <member name="M:Uno.Funcs.CreateMemoized``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})">
            <summary>
            Creates a parameterless memoized task providing function. <seealso cref="T:Uno.Extensions.FuncMemoizeExtensions"/>
            </summary>
            <typeparam name="TResult">The returned type</typeparam>
            <param name="function">The source function</param>
            <returns>A function</returns>
        </member>
        <member name="M:Uno.Funcs.CreateMemoized``2(System.Func{System.Threading.CancellationToken,``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Creates a parameterless memoized task providing function. <seealso cref="T:Uno.Extensions.FuncMemoizeExtensions"/>
            </summary>
            <typeparam name="TResult">The returned type</typeparam>
            <param name="function">The source function</param>
            <returns>A function</returns>
        </member>
        <member name="T:Uno.InternalsWriteableFromAttribute">
            <summary>
            Indicates that the attributed class has its internal properties writeable from the specified target.
            </summary>
            <remarks>
            This attribute is meant to be used by Roslyn analyzers to validate for 
            immutability, in conjuction with de-serialization scenarios where performance is an issue.
            </remarks>
        </member>
        <member name="P:Uno.InternalsWriteableFromAttribute.Source">
            <summary>
            Gets the source namespace or type that can write to the internal properties.
            </summary>
        </member>
        <member name="T:Uno.IUpdatable`1">
            <summary>
            Identifies an object that can get refreshed from another object of the same type. 	/// 
            </summary>
            <typeparam name="T"></typeparam>
            <remarks> This is useful for items bound to the view. When a newer instance with its Equals
            returning true for the old item comes in play, the old item is kept, but updated from that
            new instance.</remarks>
        </member>
        <member name="T:Uno.Key">
            <summary>
            Represents a Key concept.
            </summary>
        </member>
        <member name="M:Uno.Key.#ctor(System.Object[])">
            <summary>
            Constucts a new Key with an array of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Uno.Key.#ctor(System.Collections.IEnumerable)">
            <summary>
            Constucts a new Key with an enumeration of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Uno.Key.GetHashCode">
            <summary>
            See Object pattern.
            </summary>
        </member>
        <member name="M:Uno.Key.Equals(System.Object)">
            <summary>
            See Object pattern.
            </summary>
        </member>
        <member name="T:Uno.LegacyAttribute">
            <summary>
            Marks a member or a class as legacy. To be used in conjuction with the Obsolete attribute
            to mark elements as obsolete, but fail compilation based on static analysis rules.
            </summary>
        </member>
        <member name="M:Uno.Logging.LogExtensions.DebugIfEnabled(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Exception)">
            <summary>
            Adds a debug log, but only if debug logs are enabled. If they're not, the provided messageDelegate
            lambda will not be called.
            </summary>
            <param name="log"></param>
            <param name="messageSelector"></param>
            <param name="error"></param>
        </member>
        <member name="M:Uno.Logging.LogExtensions.InfoIfEnabled(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Exception)">
            <summary>
            Adds an info log, but only if info logs are enabled. If they're not, the provided messageDelegate
            lambda will not be called.
            </summary>
            <param name="log"></param>
            <param name="messageSelector"></param>
            <param name="error"></param>
        </member>
        <member name="M:Uno.Logging.LogExtensions.WarnIfEnabled(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Exception)">
            <summary>
            Adds a warninglog, but only if warning logs are enabled. If they're not, the provided messageDelegate
            lambda will not be called.
            </summary>
            <param name="log"></param>
            <param name="messageSelector"></param>
            <param name="error"></param>
        </member>
        <member name="M:Uno.Logging.LogExtensions.ErrorIfEnabled(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Exception)">
            <summary>
            Adds an error log, but only if error logs are enabled. If they're not, the provided messageDelegate
            lambda will not be called.
            </summary>
            <param name="log"></param>
            <param name="messageSelector"></param>
            <param name="error"></param>
        </member>
        <member name="M:Uno.Logging.LogExtensions.CriticalIfEnabled(Microsoft.Extensions.Logging.ILogger,System.Func{System.String},System.Exception)">
            <summary>
            Adds a critical error log, but only if fatal error logs are enabled. If they're not, the provided messageDelegate
            lambda will not be called.
            </summary>
            <param name="log"></param>
            <param name="messageSelector"></param>
            <param name="error"></param>
        </member>
        <member name="M:Uno.Logging.LogExtensions.LogFormat(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.Object)">
            <summary>
            Send a log message of the provided log level to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.LogFormat(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.String,System.Object)">
            <summary>
            Send a log message of the provided log level to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.LogFormat(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.String,System.Object,System.Object)">
            <summary>
            Send a log message of the provided log level to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.LogFormat(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Send a log message of the provided log level to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.LogFormat(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.String,System.Object[])">
            <summary>
            Send a log message of the provided log level to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.Log(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.String,System.Exception)">
            <summary>
            Send a log message of the provided log level to configured loggers.
            </summary>
        </member>
        <member name="M:Uno.Logging.LogExtensions.Log(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.Func{System.Object},System.Exception)">
            <summary>
            Send a log message of the provided log level to configured loggers using a deferred action to build the message,
            if the log level is enabled.
            </summary>
        </member>
        <member name="M:Uno.Logging.LogExtensions.TraceFormat(Microsoft.Extensions.Logging.ILogger,System.Object)">
            <summary>
            Send a "Trace" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsTraceEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.TraceFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object)">
            <summary>
            Send a "Trace" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsTraceEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.TraceFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object,System.Object)">
            <summary>
            Send a "Trace" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsTraceEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.TraceFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Send a "Trace" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsTraceEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.TraceFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object[])">
            <summary>
            Send a "Trace" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsTraceEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.Trace(Microsoft.Extensions.Logging.ILogger,System.String,System.Exception)">
            <summary>
            Send a "Trace" message to configured loggers.
            </summary>
        </member>
        <member name="M:Uno.Logging.LogExtensions.Trace(Microsoft.Extensions.Logging.ILogger,System.Func{System.Object},System.Exception)">
            <summary>
            Send a "Trace" message to configured loggers using a deferred action to build the message,
            if the Trace log level is enabled.
            </summary>
        </member>
        <member name="M:Uno.Logging.LogExtensions.DebugFormat(Microsoft.Extensions.Logging.ILogger,System.Object)">
            <summary>
            Send a "Debug" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsDebugEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.DebugFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object)">
            <summary>
            Send a "Debug" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsDebugEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.DebugFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object,System.Object)">
            <summary>
            Send a "Debug" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsDebugEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.DebugFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Send a "Debug" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsDebugEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.DebugFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object[])">
            <summary>
            Send a "Debug" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsDebugEnabled
            first to prevent useless processing constructing a logging message.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.Debug(Microsoft.Extensions.Logging.ILogger,System.String,System.Exception)">
            <summary>
            Send a "Debug" message to configured loggers.
            </summary>
        </member>
        <member name="M:Uno.Logging.LogExtensions.Debug(Microsoft.Extensions.Logging.ILogger,System.Func{System.Object},System.Exception)">
            <summary>
            Send a "Debug" message to configured loggers using a deferred action to build the message,
            if the Debug log level is enabled.
            </summary>
        </member>
        <member name="M:Uno.Logging.LogExtensions.InfoFormat(Microsoft.Extensions.Logging.ILogger,System.Object)">
            <summary>
            Send a "Info" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsInfoEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Info" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.InfoFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object)">
            <summary>
            Send a "Info" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsInfoEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Info" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.InfoFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object,System.Object)">
            <summary>
            Send a "Info" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsInfoEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Info" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.InfoFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Send a "Info" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsInfoEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Info" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.InfoFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object[])">
            <summary>
            Send a "Info" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsInfoEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Info" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.Info(Microsoft.Extensions.Logging.ILogger,System.String,System.Exception)">
            <summary>
            Send a "Info" message to configured loggers.
            </summary>
        </member>
        <member name="M:Uno.Logging.LogExtensions.Info(Microsoft.Extensions.Logging.ILogger,System.Func{System.Object},System.Exception)">
            <summary>
            Send a "Info" message to configured loggers using a deferred action to build the message,
            if the Info log level is enabled.
            </summary>
        </member>
        <member name="M:Uno.Logging.LogExtensions.WarnFormat(Microsoft.Extensions.Logging.ILogger,System.Object)">
            <summary>
            Send a "Warn" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsWarnEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Warn" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.WarnFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object)">
            <summary>
            Send a "Warn" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsWarnEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Warn" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.WarnFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object,System.Object)">
            <summary>
            Send a "Warn" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsWarnEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Warn" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.WarnFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Send a "Warn" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsWarnEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Warn" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.WarnFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object[])">
            <summary>
            Send a "Warn" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsWarnEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Warn" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.Warn(Microsoft.Extensions.Logging.ILogger,System.Func{System.Object},System.Exception)">
            <summary>
            Send a "Warn" message to configured loggers using a deferred action to build the message,
            if the Warn log level is enabled.
            </summary>
        </member>
        <member name="M:Uno.Logging.LogExtensions.Warn(Microsoft.Extensions.Logging.ILogger,System.String,System.Exception)">
            <summary>
            Send a "Warn" message to configured loggers.
            </summary>
        </member>
        <member name="M:Uno.Logging.LogExtensions.ErrorFormat(Microsoft.Extensions.Logging.ILogger,System.Object)">
            <summary>
            Send a "Error" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsErrorEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Error" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.ErrorFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object)">
            <summary>
            Send a "Error" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsErrorEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Error" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.ErrorFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object,System.Object)">
            <summary>
            Send a "Error" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsErrorEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Error" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.ErrorFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Send a "Error" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsErrorEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Error" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.ErrorFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object[])">
            <summary>
            Send a "Error" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsErrorEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Error" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.Error(Microsoft.Extensions.Logging.ILogger,System.String,System.Exception)">
            <summary>
            Send a "Error" message to configured loggers using a deferred action to build the message,
            if the Error log level is enabled.
            </summary>
        </member>
        <member name="M:Uno.Logging.LogExtensions.Error(Microsoft.Extensions.Logging.ILogger,System.Func{System.Object},System.Exception)">
            <summary>
            Send a "Error" message to configured loggers using a deferred action to build the message,
            if the Error log level is enabled.
            </summary>
        </member>
        <member name="M:Uno.Logging.LogExtensions.CriticalFormat(Microsoft.Extensions.Logging.ILogger,System.Object)">
            <summary>
            Send a "Critical" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsCriticalEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Critical" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.CriticalFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object)">
            <summary>
            Send a "Critical" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsCriticalEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Critical" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.CriticalFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object,System.Object)">
            <summary>
            Send a "Critical" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsCriticalEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Critical" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.CriticalFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Send a "Critical" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsCriticalEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Critical" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.CriticalFormat(Microsoft.Extensions.Logging.ILogger,System.String,System.Object[])">
            <summary>
            Send a "Critical" message to configured loggers.
            </summary>
            <remarks>
            If the construction of the message is costly, you should check the .IsCriticalEnabled
            first to prevent useless processing constructing a logging message.
            Note: "Critical" is usually always available.
            </remarks>
        </member>
        <member name="M:Uno.Logging.LogExtensions.Critical(Microsoft.Extensions.Logging.ILogger,System.String,System.Exception)">
            <summary>
            Send a "Critical" message to configured loggers using a deferred action to build the message,
            if the Critical log level is enabled.
            </summary>
        </member>
        <member name="M:Uno.Logging.LogExtensions.Critical(Microsoft.Extensions.Logging.ILogger,System.Func{System.Object},System.Exception)">
            <summary>
            Send a "Critical" message to configured loggers using a deferred action to build the message,
            if the Critical log level is enabled.
            </summary>
        </member>
        <member name="T:Uno.Null">
            <summary>
            A container for a object that has no meaning (replaces void).
            </summary>
        </member>
        <member name="M:Uno.Null.#ctor">
            <summary>
            Private constructor, no one will ever construct these things, pass null.
            </summary>
        </member>
        <member name="T:Uno.NullDisposable">
            <summary>
            An empty implementation of the IDisposable class.
            </summary>
        </member>
        <member name="F:Uno.NullDisposable.Instance">
            <summary>
            Provider for a instance of the NullDisposable
            </summary>
        </member>
        <member name="M:Uno.NullDisposable.#ctor">
            <summary>
            Private constructor, use Instance.
            </summary>
        </member>
        <member name="M:Uno.NullDisposable.Dispose">
            <summary>
            See IDisposable.
            </summary>
        </member>
        <member name="T:Uno.ReferenceEqualityComparer`1">
            <summary>
            A reference equality comparer for instances.
            </summary>
        </member>
        <member name="T:Uno.None`1">
            <summary>
            Special Option representing an absence of value.
            </summary>
            <remarks>
            This is the implementation of a functional "Option Type" using F# semantic
            https://en.wikipedia.org/wiki/Option_type
            </remarks>
        </member>
        <member name="P:Uno.None`1.Instance">
            <summary>
            Singleton instance of this
            </summary>
        </member>
        <member name="M:Uno.None`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Uno.None`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Uno.None`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Uno.Option">
            <summary>
            Static method to create an <see cref="T:Uno.Option`1"/>
            </summary>
        </member>
        <member name="M:Uno.Option.None``1">
            <summary>
            Creates an option which represent an absence of value.
            </summary>
        </member>
        <member name="M:Uno.Option.Some``1(``0)">
            <summary>
            Creates an option for a given value.
            </summary>
        </member>
        <member name="M:Uno.Option.MatchNone">
            <summary>
            Gets a bool which indicates if this otion is <see cref="M:Uno.Option.Some``1(``0)"/> or not.
            </summary>
        </member>
        <member name="M:Uno.Option.MatchSome">
            <summary>
            Gets a bool which indicates if this otion is <see cref="M:Uno.Option.Some``1(``0)"/> or not
            </summary>
        </member>
        <member name="M:Uno.Option.MatchSome(System.Object@)">
            <summary>
            Gets a bool which indicates if this otion is <see cref="M:Uno.Option.Some``1(``0)"/> or not and send back the value.
            </summary>
        </member>
        <member name="T:Uno.Option`1">
            <summary>
            This is a base class for an option.
            </summary>
            <remarks>
            This is the implementation of a functional "Option Type" using F# semantic
            https://en.wikipedia.org/wiki/Option_type
            </remarks>
        </member>
        <member name="M:Uno.Option`1.MatchSome(`0@)">
            <summary>
            Gets a bool which indicates if this otion is <see cref="T:Uno.Some`1"/> or not and send back the value.
            </summary>
        </member>
        <member name="M:Uno.Option`1.op_Implicit(Uno.Option{`0})~`0">
            <summary>
            Implicit conversion from <see cref="T:Uno.Option`1"/> to T.
            </summary>
            <remarks>
            `null` or `None` will become `default(T)`.
            </remarks>
            <param name="o"></param>
        </member>
        <member name="M:Uno.Option`1.op_Implicit(`0)~Uno.Option{`0}">
            <summary>
            Implicit conversion of T to <see cref="T:Uno.Some`1"/>
            </summary>
        </member>
        <member name="T:Uno.OptionEqualityComparer`1">
            <summary>
            This is an implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which compare the
            <see cref="T:Uno.Option`1"/> type and uses an optional inner comparer for the value.
            </summary>
        </member>
        <member name="M:Uno.OptionEqualityComparer`1.Equals(Uno.Option{`0},Uno.Option{`0})">
            <inheritdoc />
        </member>
        <member name="M:Uno.OptionEqualityComparer`1.GetHashCode(Uno.Option{`0})">
            <inheritdoc />
        </member>
        <member name="T:Uno.OptionExtensions">
            <summary>
            Extension methods over <see cref="T:Uno.Option`1"/>.
            </summary>
        </member>
        <member name="M:Uno.OptionExtensions.Bind``2(Uno.Option{``0},System.Func{``0,Uno.Option{``1}})">
            <summary>
            Creates an <see cref="T:Uno.Option`1"/> using an <see cref="T:Uno.Option`1"/>.
            </summary>
            <typeparam name="T1">Type of the source option</typeparam>
            <typeparam name="T2">Type of the target option</typeparam>
            <param name="option">The source option</param>
            <param name="func">Method to create an <see cref="T:Uno.Option`1"/> for a given <typeparamref name="T1"/>.</param>
            <returns>The resulting option</returns>
        </member>
        <member name="M:Uno.OptionExtensions.Map``2(Uno.Option{``0},System.Func{``0,``1})">
            <summary>
            Convert an <see cref="T:Uno.Option`1"/> to an <see cref="T:Uno.Option`1"/>
            </summary>
            <typeparam name="T1">Type of the source option</typeparam>
            <typeparam name="T2">Type of the target option</typeparam>
            <param name="option">The source option to convert</param>
            <param name="func">Method to convert the value of the source to the value the target</param>
            <returns>The converted option</returns>
        </member>
        <member name="M:Uno.OptionExtensions.SomeOrDefault``1(Uno.Option{``0},``0)">
            <summary>
            Gets the value of the option or default(<typeparamref name="T"/>) if none.
            </summary>
            <typeparam name="T">Type of the option</typeparam>
            <param name="option">The source option from which the value have to be extracted</param>
            <returns>The value of the option or default(<typeparamref name="T"/>) if none.</returns>
        </member>
        <member name="M:Uno.OptionExtensions.SomeOrDefault(Uno.Option,System.Object)">
            <summary>
            Gets the value of the option or default(object) if none.
            </summary>
            <param name="option">The source option from which the value have to be extracted</param>
            <returns>The value of the option or default(object) if none.</returns>
        </member>
        <member name="T:Uno.OptionType">
            <summary>
            Represents the different possible types of an <see cref="T:Uno.Option`1"/>
            </summary>
        </member>
        <member name="F:Uno.OptionType.None">
            <summary>
            The option does not have value
            </summary>
        </member>
        <member name="F:Uno.OptionType.Some">
            <summary>
            The option have a value
            </summary>
        </member>
        <member name="T:Uno.Some`1">
            <summary>
            Option holding a value.
            </summary>
            <remarks>
            This is the implementation of a functional "Option Type" using F# semantic
            https://en.wikipedia.org/wiki/Option_type
            </remarks>
        </member>
        <member name="M:Uno.Some`1.#ctor(`0)">
            <summary>
            Creates an <see cref="T:Uno.Option`1"/> for a given value
            </summary>
            <param name="value">The value hold by the option</param>
        </member>
        <member name="P:Uno.Some`1.Value">
            <summary>
            Gets the value
            </summary>
        </member>
        <member name="M:Uno.Some`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Uno.Some`1.Equals(Uno.Some{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Uno.Some`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Uno.Some`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Uno.Some`1.op_Implicit(`0)~Uno.Some{`0}">
            <summary>
            Implicit conversion of T to <see cref="T:Uno.Some`1"/>
            </summary>
        </member>
        <member name="T:Uno.Pair`1">
            <summary>
            Represents a Pair of Ts.
            </summary>
            <typeparam name="T">The type of elements in this Pair.</typeparam>
        </member>
        <member name="M:Uno.Pair`1.#ctor">
            <summary>
            Constructs a new Pair.
            </summary>
        </member>
        <member name="M:Uno.Pair`1.#ctor(`0,`0)">
            <summary>
            Constructs a new Pair with it's X and Y items set.
            </summary>
            <param name="x">The X item.</param>
            <param name="y">The Y item.</param>
        </member>
        <member name="P:Uno.Pair`1.X">
            <summary>
            Accessor for the X item.
            </summary>
        </member>
        <member name="P:Uno.Pair`1.Y">
            <summary>
            Acessor for the Y item.
            </summary>
        </member>
        <member name="M:Uno.Pair`1.GetHashCode">
            <summary>
            See Object pattern.
            </summary>
        </member>
        <member name="M:Uno.Pair`1.Equals(System.Object)">
            <summary>
            See Object pattern.
            </summary>
        </member>
        <member name="T:Uno.Predicates">
            <summary>
            A set of common prediactes
            </summary>
        </member>
        <member name="F:Uno.Predicates.Equal">
            <summary>
            A predicate that checks equality of two objects using the <see cref="T:Uno.Extensions.EqualityExtensions"/>.
            </summary>
        </member>
        <member name="F:Uno.Predicates.ReferenceEqual">
            <summary>
            A predicate that checks if two objects are <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            </summary>
        </member>
        <member name="F:Uno.Predicates.True">
            <summary>
            A predicate that always returns true.
            </summary>
        </member>
        <member name="F:Uno.Predicates.False">
            <summary>
            A predicate that always returns false.
            </summary>
        </member>
        <member name="T:Uno.Predicates`1">
            <summary>
            A set of common prediactes
            </summary>
            <typeparam name="T">Type of parameter of predicates</typeparam>
        </member>
        <member name="F:Uno.Predicates`1.Equal">
            <summary>
            A predicate that checks equality of two instances of <typeparamref name="T"/> using the <see cref="T:Uno.Extensions.EqualityExtensions"/>.
            </summary>
        </member>
        <member name="F:Uno.Predicates`1.ReferenceEqual">
            <summary>
            A predicate that checks if two instances of <typeparamref name="T"/> are <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            </summary>
        </member>
        <member name="F:Uno.Predicates`1.True">
            <summary>
            A predicate that always returns true.
            </summary>
        </member>
        <member name="F:Uno.Predicates`1.False">
            <summary>
            A predicate that always returns false.
            </summary>
        </member>
        <member name="M:Uno.Reflection.FieldDescriptor.ToCompiledSetValue">
            <summary>
            Creates a compiled method that will allow a the assignation of the specified field.
            </summary>
            <param name="fieldInfo">The field to assign</param>
            <returns>A delegate taking an instance as the first parameter, and the value as the second parameter.</returns>
        </member>
        <member name="M:Uno.Reflection.FieldDescriptor.ToCompiledSetValue(System.Boolean)">
            <summary>
            Creates a compiled method that will allow a the assignation of the specified field.
            </summary>
            <param name="fieldInfo">The field to assign</param>
            <param name="strict">Removes some type checking to enhance performance if set to false.</param>
            <returns>A delegate taking an instance as the first parameter, and the value as the second parameter.</returns>
            <remarks>
            The use of the strict parameter is required if the caller of the generated method does not validate 
            parameter types before the call. Invalid parameters could result in unexpected behavior.
            </remarks>
        </member>
        <member name="M:Uno.Reflection.FieldDescriptor.ToCompiledSetValue(System.RuntimeTypeHandle,System.RuntimeFieldHandle,System.Boolean)">
            <summary>
            Creates a compiled method that will allow a the assignation of the specified field.
            </summary>
            <param name="typeHandle">The declaring type for the specified RuntimeFieldHandle</param>
            <param name="fieldHandle">The field in the specified RuntimeTypeHandle</param>
            <param name="strict">Removes some type checking to enhance performance.</param>
            <returns>A delegate taking an instance as the first parameter, and the value as the second parameter.</returns>
            <remarks>
            The use of the strict parameter is required if the caller of the generated method does not validate 
            parameter types before the call. Invalid parameters could result in unexpected behavior.
            </remarks>
        </member>
        <member name="M:Uno.Reflection.FieldDescriptor.ToCompiledGetValue">
            <summary>
            Creates a compiled method that will get the value of a field 
            </summary>
            <param name="fieldInfo">The field to get the value from.</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Reflection.FieldDescriptor.ToCompiledGetValue(System.Boolean)">
            <summary>
            Creates a compiled method that will get the value of a field.
            </summary>
            <param name="fieldInfo">The field to get the value from.</param>
            <param name="strict">Removes some type checking to enhance performance if set to false.</param>
            <returns>A delegate taking an instance as the first parameter, and returns the value of the field.</returns>
            <remarks>
            The use of the strict parameter is required if the caller of the generated method does not validate 
            parameter types before the call. An invalid parameter could result in unexpected behavior.
            </remarks>
        </member>
        <member name="M:Uno.Reflection.FieldDescriptor.ToCompiledGetValue(System.RuntimeTypeHandle,System.RuntimeFieldHandle,System.Boolean)">
            <summary>
            Creates a compiled method that will get the value of a field.
            </summary>
            <param name="typeHandle">The declaring type for the specified RuntimeFieldHandle</param>
            <param name="fieldHandle">The field in the specified RuntimeTypeHandle</param>
            <param name="strict">Removes some type checking to enhance performance if set to false.</param>
            <returns></returns>
            <remarks>
            The use of the strict parameter is required if the caller of the generated method does not validate 
            parameter types before the call. An invalid parameter could result in unexpected behavior.
            </remarks>
        </member>
        <member name="M:Uno.Reflection.IMethodDescriptor.ToCompiledMethodInvoke">
            <summary>
            Build a compiled method that will call the specified method.
            </summary>
            <param name="MethodInfo">The method to invoke</param>
            <returns>A delegate that will call the requested method</returns>
        </member>
        <member name="M:Uno.Reflection.IMethodDescriptor.ToCompiledMethodInvoke(System.Boolean)">
            <summary>
            Build a compiled method that will call the specified method.
            </summary>
            <param name="MethodInfo">The method to invoke</param>
            <param name="strict">Removes some type checking to enhance performance if set to false.</param>
            <returns>A delegate that will call the requested method</returns>
            <remarks>
            The use of the strict parameter is required if the caller of the generated method does not validate 
            parameter types before the call. An invalid parameter could result in unexpected behavior.
            </remarks>
        </member>
        <member name="M:Uno.Reflection.IValueMemberDescriptor.ToCompiledSetValue">
            <summary>
            Creates a compiled method that will allow a the assignation of the current member.
            </summary>
            <returns>A delegate taking an instance as the first parameter, and the value as the second parameter.</returns>
        </member>
        <member name="M:Uno.Reflection.IValueMemberDescriptor.ToCompiledSetValue(System.Boolean)">
            <summary>
            Creates a compiled method that will allow a the assignation of the current member.
            </summary>
            <param name="strict">Removes some type checking to enhance performance if set to false.</param>
            <returns>A delegate taking an instance as the first parameter, and the value as the second parameter.</returns>
            <remarks>
            The use of the strict parameter is required if the caller of the generated method does not validate 
            parameter types before the call. Invalid parameters could result in unexpected behavior.
            </remarks>
        </member>
        <member name="M:Uno.Reflection.IValueMemberDescriptor.ToCompiledGetValue">
            <summary>
            Creates a compiled method that will get the value of  of the current member. 
            </summary>
            <param name="fieldInfo">The field to get the value from.</param>
            <returns></returns>
        </member>
        <member name="M:Uno.Reflection.IValueMemberDescriptor.ToCompiledGetValue(System.Boolean)">
            <summary>
            Creates a compiled method that will get the value of  of the current member.
            </summary>
            <param name="fieldInfo">The field to get the value from.</param>
            <param name="strict">Removes some type checking to enhance performance if set to false.</param>
            <returns>A delegate taking an instance as the first parameter, and returns the value of the field.</returns>
            <remarks>
            The use of the strict parameter is required if the caller of the generated method does not validate 
            parameter types before the call. An invalid parameter could result in unexpected behavior.
            </remarks>
        </member>
        <member name="T:Uno.Runtime">
            <summary>
            Runtime information helper class
            </summary>
        </member>
        <member name="M:Uno.Runtime.IsLocalUri(System.Uri)">
            <summary>
            Returns true if the uri is a local uri (isolated storage, linked as content, resource, etc.)
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Runtime.GetSafeFilename(System.String)">
            <summary>
            Returns a safe filename for a string token.
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="T:Uno.Threading.AsyncLock">
            <summary>
            An asynchronous lock, that can be used in conjuction with C# async/await
            </summary>
        </member>
        <member name="M:Uno.Threading.AsyncLock.LockAsync(System.Threading.CancellationToken)">
            <summary>
            Acquires the lock, then provides a disposable to release it.
            </summary>
            <param name="ct">A cancellation token to cancel the lock</param>
            <returns>An IDisposable instance that allows the release of the lock.</returns>
        </member>
        <member name="T:Uno.Threading.FastAsyncLock">
            <summary>
            An re-entrant asynchronous lock, that can be used in conjuction with C# async/await
            </summary>
        </member>
        <member name="M:Uno.Threading.FastAsyncLock.LockAsync(System.Threading.CancellationToken)">
            <summary>
            Acquires the lock, then provides a disposable to release it.
            </summary>
            <param name="ct">A cancellation token to cancel the acquisition of the lock</param>
            <returns>An IDisposable instance that allows the release of the lock.</returns>
        </member>
        <member name="T:Uno.Threading.FastAsyncLock.Handle">
            <summary>
            An handle on an async lock which makes sure that disposing it mutiple times won't exit the monitor multiple times
            </summary>
        </member>
        <member name="T:Uno.Threading.FastTaskCompletionSource`1">
            <summary>
            This is a lightweight alternative to TaskCompletionSource.
            </summary>
            <remarks>
            In most situation, the TaskCompletionSource could be replaced directly by this one.
            It is sligthly more efficient to use the .Task insead of directly awaiting this object.
            </remarks>
        </member>
        <member name="P:Uno.Threading.FastTaskCompletionSource`1.Termination">
            <summary>
            Current state of the object
            </summary>
        </member>
        <member name="P:Uno.Threading.FastTaskCompletionSource`1.IsCompleted">
            <summary>
            If any termination has been set
            </summary>
        </member>
        <member name="P:Uno.Threading.FastTaskCompletionSource`1.IsCanceled">
            <summary>
            If SetCanceled has been called.
            </summary>
            <remarks>
            Calling SetException with a "TaskCanceledException" will produce the same result.
            </remarks>
        </member>
        <member name="P:Uno.Threading.FastTaskCompletionSource`1.ExceptionInfo">
            <summary>
            The capture of the original exception, if any.
            </summary>
            <remarks>
            Will be null until a SetException() has been called.
            NOTE: will be null if SetException is called with a "TaskCanceledException".
            </remarks>
        </member>
        <member name="P:Uno.Threading.FastTaskCompletionSource`1.Result">
            <summary>
            The result, if any.
            </summary>
            <remarks>
            Will be null until a SetResult() has been called.
            </remarks>
        </member>
        <member name="P:Uno.Threading.FastTaskCompletionSource`1.Exception">
            <summary>
            Get the captured exception (if any) - null if none or N/A
            </summary>
            <remarks>
            Will be null until a SetException() has been called.
            NOTE: will be null if SetException is called with a "TaskCanceledException".
            </remarks>
        </member>
        <member name="M:Uno.Threading.FastTaskCompletionSource`1.SetCanceled">
            <summary>
            Set the termination as "Canceled"
            </summary>
            <remarks>
            Will throw an InvalidOperationException if a termination has been set.
            Calling SetException with a "TaskCanceledException" will produce the same result.
            </remarks>
        </member>
        <member name="M:Uno.Threading.FastTaskCompletionSource`1.TrySetCanceled">
            <summary>
            Set the termination as "Canceled"
            </summary>
            <remarks>
            Calling SetException with a "TaskCanceledException" will produce the same result.
            </remarks>
        </member>
        <member name="M:Uno.Threading.FastTaskCompletionSource`1.SetException(System.Exception)">
            <summary>
            Set the termination on an exception
            </summary>
            <remarks>
            Will throw an InvalidOperationException if a termination has been set.
            Calling SetException with a "TaskCanceledException" will result as a if SetCanceled() has been called.
            </remarks>
        </member>
        <member name="M:Uno.Threading.FastTaskCompletionSource`1.SetException(System.Runtime.ExceptionServices.ExceptionDispatchInfo)">
            <summary>
            Set the termination on an exception wrapped in an ExceptionDispatchInfo
            </summary>
            <remarks>
            Will throw an InvalidOperationException if a termination has been set.
            Calling SetException with a "TaskCanceledException" will result as a if SetCanceled() has been called.
            </remarks>
        </member>
        <member name="M:Uno.Threading.FastTaskCompletionSource`1.TrySetException(System.Exception)">
            <summary>
            Set the termination on an exception
            </summary>
            <remarks>
            Calling SetException with a "TaskCanceledException" will result as a if SetCanceled() has been called.
            </remarks>
        </member>
        <member name="M:Uno.Threading.FastTaskCompletionSource`1.TrySetException(System.Runtime.ExceptionServices.ExceptionDispatchInfo)">
            <summary>
            Set the termination on an exception wrapped in an ExceptionDispatchInfo
            </summary>
            <remarks>
            Calling SetException with a "TaskCanceledException" will result as a if SetCanceled() has been called.
            </remarks>
        </member>
        <member name="M:Uno.Threading.FastTaskCompletionSource`1.SetResult(`0)">
            <summary>
            Set the termination on a result
            </summary>
            <remarks>
            Will throw an InvalidOperationException if a termination has been set.
            </remarks>
        </member>
        <member name="M:Uno.Threading.FastTaskCompletionSource`1.TrySetResult(`0)">
            <summary>
            Set the termination on a result
            </summary>
        </member>
        <member name="M:Uno.Threading.FastTaskCompletionSource`1.GetResult">
            <summary>
            GetResult or throw an exception, according to termination. BLOCKING: DON'T CALL THIS!
            </summary>
            <remarks>
            BLOCKING CALL!  Will wait until a termination has been set.
            The method is resigned for the "await" pattern, should not be called from code.
            </remarks>
        </member>
        <member name="M:Uno.Threading.FastTaskCompletionSource`1.GetAwaiter">
            <summary>
            "await" pattern implementation.
            </summary>
        </member>
        <member name="M:Uno.Threading.FastTaskCompletionSource`1.OnCompleted(System.Action)">
            <summary>
            "await" pattern implementation.
            </summary>
        </member>
        <member name="P:Uno.Threading.FastTaskCompletionSource`1.Task">
            <summary>
            Task you can use to await for the result.
            </summary>
        </member>
        <member name="M:Uno.Threading.ISynchronizableLock`1.Write(System.Int32,System.Func{`0,System.Boolean},System.Action{`0})">
            <summary>
            Performs a write operation if the read operation return false.
            </summary>
            <param name="millisecondsTimeout">The timeout to acquire the write lock</param>
            <param name="read">A lambda that will test if the data can be read</param>
            <param name="write">A lambda that will perform the write if the read failed</param>
            <returns>true if the read succeeded, otherwise false.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Uno.Threading.ThreadLocalSource`1" -->
        <member name="M:Uno.Threading.ThreadLocalSource`1.#ctor">
            <summary>
            Initialize the ThreadLocalSource with no value for current thread (will be default(T))
            </summary>
        </member>
        <member name="M:Uno.Threading.ThreadLocalSource`1.#ctor(`0)">
            <summary>
            Initialize the ThreadLocalSource with a starting value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Uno.Transactional.Update``1(``0@,System.Func{``0,``0})">
            <summary>
            Transactionally updates the <paramref name="original"/> reference using the provided <paramref name="selector"/>.
            </summary>
            <typeparam name="T">The type of the reference to update</typeparam>
            <param name="original">A ref variable to the original value</param>
            <param name="selector">A selector method that creates an updated version of the original value</param>
            <returns>Successful updated version</returns>
        </member>
        <member name="M:Uno.Transactional.Update(System.Object@,System.Func{System.Object,System.Object})">
            <summary>
            Transactionally updates the <paramref name="original"/> reference using the provided <paramref name="selector"/>.
            </summary>
            <param name="original">A ref variable to the original value</param>
            <param name="selector">A selector method that creates an updated version of the original value</param>
            <returns>Successful updated version</returns>
        </member>
        <member name="M:Uno.Transactional.Update``2(``0@,``1,System.Func{``0,``1,``0})">
            <summary>
            Transactionally updates the <paramref name="original"/> reference using the provided <paramref name="selector"/>.
            </summary>
            <remarks>
            This version let you pass a parameter to prevent creation of a display class for capturing data in your lambda
            </remarks>
            <typeparam name="T">The type of the reference to update</typeparam>
            <param name="original">A ref variable to the <paramref name="original"/> value</param>
            <param name="selector">A selector method that creates an updated version of the original value</param>
            <returns>Successful updated version</returns>
        </member>
        <member name="M:Uno.Transactional.Update``3(``0@,``1,``2,System.Func{``0,``1,``2,``0})">
            <summary>
            Transactionally updates the <paramref name="original"/> reference using the provided <paramref name="selector"/>.
            </summary>
            <remarks>
            This version let you pass a parameters to prevent creation of a display class for capturing data in your lambda
            </remarks>
            <typeparam name="T">The type of the reference to update</typeparam>
            <param name="original">A ref variable to the original value</param>
            <param name="selector">A selector method that creates an updated version of the original value</param>
            <returns>Successful updated version</returns>
        </member>
        <member name="M:Uno.Transactional.Update``2(``0@,System.Func{``0,System.Tuple{``0,``1}})">
            <summary>
            Transactionally updates the <paramref name="original"/> reference using the provided
            <paramref name="selector"/>, and returns a selected value from the <paramref name="selector"/>.
            </summary>
            <typeparam name="TSource">The type of the reference to update</typeparam>
            <typeparam name="TResult">The inner value from the updated TSource returned by the selector</typeparam>
            <param name="original">The original value reference</param>
            <param name="selector">The selector returning a Tuple with updated value as Item1 and Update result as Item2.</param>
            <returns>The inner value returned by the selector.</returns>
        </member>
        <member name="M:Uno.Transactional.Update``3(``0@,``1,System.Func{``0,``1,System.Tuple{``0,``2}})">
            <summary>
            Transactionally updates the <paramref name="original"/> reference using the provided
            <paramref name="selector"/>, and returns a selected value from the <paramref name="selector"/>.
            </summary>
            <typeparam name="TSource">The type of the reference to update</typeparam>
            <typeparam name="TResult">The inner value from the updated TSource returned by the selector</typeparam>
            <param name="original">The original value reference</param>
            <param name="selector">The selector returning a Tuple with updated value as Item1 and Update result as Item2.</param>
            <returns>The inner value returned by the selector.</returns>
        </member>
        <member name="M:Uno.Transactional.GetOrAdd``3(``0@,``1,System.Func{``1,``2})">
            <summary>
            Transactionally get or add an item to an ImmutableDictionary.  The factory is called to create the item when required.
            </summary>
        </member>
        <member name="M:Uno.Transactional.GetOrAdd``4(``0@,``1,``2,System.Func{``1,``2,``3})">
            <summary>
            Transactionally get or add an item to an ImmutableDictionary.  The factory is called to create the item when required.
            </summary>
            <remarks>This overload is used primarily to avoid creating a closure, which are expensive when running under Monos full AOT.</remarks>
        </member>
        <member name="M:Uno.Transactional.TryAdd``3(``0@,``1,System.Func{``1,``2},``2@)">
            <summary>
            Transactionally add an item to an ImmutableDictionary if not already present.  The factory is called to create the item when required.
            </summary>
        </member>
        <member name="M:Uno.Transactional.TryRemove``3(``0@,``1,``2@)">
            <summary>
            Transactionally remove an item from an ImmutableDictionary if exists.
            </summary>
        </member>
        <member name="M:Uno.Transactional.Remove``3(``0@,System.Func{System.Collections.Generic.KeyValuePair{``1,``2},System.Boolean})">
            <summary>
            Transactionally remove an item from a list.
            </summary>
            <returns>True if the item was in the list, false else.</returns>
        </member>
        <member name="M:Uno.Transactional.SetItem``3(``0@,``1,``2)">
            <summary>
            Transactionally set an item of an ImmutableDictionary.
            </summary>
        </member>
        <member name="M:Uno.Transactional.SetItem``3(``0@,``1,System.Func{``1,``2})">
            <summary>
            Transactionally set an item of an ImmutableDictionary.
            </summary>
        </member>
        <member name="M:Uno.Transactional.TryUpdateItem``3(``0@,``1,``2)">
            <summary>
            Transactionally update an item of an ImmutableDictionary, *but only if it already exists in the dictionary*.
            The factory is called to create the item when required, and may be invoked multiple times.
            </summary>
        </member>
        <member name="M:Uno.Transactional.TryUpdateItem``2(System.Collections.Immutable.IImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1,``1})">
            <summary>
            Transactionally update an item of an ImmutableDictionary, *but only if it already exists in the dictionary*.
            The factory is called to create the item when required, and may be invoked multiple times.
            </summary>
        </member>
        <member name="M:Uno.Transactional.TryUpdateItem``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1,``1})">
            <summary>
            Transactionally update an item of an ImmutableDictionary, *but only if it already exists in the dictionary*.
            The factory is called to create the item when required, and may be invoked multiple times.
            </summary>
        </member>
        <member name="M:Uno.Transactional.TryUpdateItem``2(System.Collections.Immutable.ImmutableSortedDictionary{``0,``1}@,``0,System.Func{``0,``1,``1})">
            <summary>
            Transactionally update an item of an ImmutableDictionary, *but only if it already exists in the dictionary*.
            The factory is called to create the item when required, and may be invoked multiple times.
            </summary>
        </member>
        <member name="M:Uno.Transactional.UpdateItem``2(System.Collections.Immutable.IImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1,``1})">
            <summary>
            Transactionally update an item of an ImmutableDictionary. 
            The factory is called to update the item, and may be invoked multiple times.
            </summary>
        </member>
        <member name="M:Uno.Transactional.UpdateItem``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1,``1})">
            <summary>
            Transactionally get or add an item to an ImmutableDictionary.  The factory is called to create the item when required.
            The factory is called to udpate, and may be invoked multiple times.
            </summary>
        </member>
        <member name="M:Uno.Transactional.UpdateItem``2(System.Collections.Immutable.ImmutableSortedDictionary{``0,``1}@,``0,System.Func{``0,``1,``1})">
            <summary>
            Transactionally update an item of an ImmutableDictionary.
            The factory is called to udpate, and may be invoked multiple times.
            </summary>
        </member>
        <member name="M:Uno.Transactional.Enqueue``2(``0@,``1)">
            <summary>
            Transactionally enqueue and item into an ImmutableQueue
            </summary>
        </member>
        <member name="M:Uno.Transactional.Enqueue``2(``0@,System.Func{``0,``1})">
            <summary>
            Transactionally enqueue and item into an ImmutableQueue
            </summary>
        </member>
        <member name="M:Uno.Transactional.TryDequeue``2(``0@,``1@)">
            <summary>
            Transactionally dequeue an item from a queue.
            </summary>
            <returns>true if successful, false means queue was empty</returns>
        </member>
        <member name="M:Uno.Transactional.Dequeue``2(``0@)">
            <summary>
            Transactionally dequeue an item from a queue. An exception is thrown if queue is empty.
            </summary>
            <returns>dequeued item</returns>
        </member>
        <member name="M:Uno.Transactional.Add``2(``0@,``1)">
            <summary>
            Transactionally add an item to a list.
            </summary>
        </member>
        <member name="M:Uno.Transactional.AddDistinct``2(``0@,``1)">
            <summary>
            Transactionally add an item to a list if not already present.
            </summary>
        </member>
        <member name="M:Uno.Transactional.AddDistinct``2(``0@,``1,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Transactionally add an item to a list if not already present.
            </summary>
        </member>
        <member name="M:Uno.Transactional.TryAddDistinct``2(``0@,``1)">
            <summary>
            Transactionally try to add an item to a list if not already present.
            </summary>
            <returns>True if item was added, false if item was already present</returns>
        </member>
        <member name="M:Uno.Transactional.TryAddDistinct``2(``0@,``1,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Transactionally try to add an item to a list if not already present.
            </summary>
            <returns>True if item was added, false if item was already present</returns>
        </member>
        <member name="M:Uno.Transactional.Remove``2(``0@,``1)">
            <summary>
            Transactionally remove an item from a list.
            </summary>
            <returns>True if the item was in the list, false else.</returns>
        </member>
        <member name="M:Uno.Transactional.Remove``2(``0@,System.Func{``1,System.Boolean})">
            <summary>
            Remove item(s) from an immutable list using a selector.
            </summary>
            <returns>True if the item was in the list, false else.</returns>
        </member>
        <member name="M:Uno.Transactional.RemoveRange``2(``0@,``1[])">
            <summary>
            Transactionally remove the specified items from a list.
            </summary>
            <returns>Number of items which were effectively removed from the list.</returns>
        </member>
        <member name="M:Uno.Transactional.RemoveRange``2(``0@,``1[],System.Collections.Generic.IEnumerable{``1}@)">
            <summary>
            Transactionally remove the specified items from a list.
            </summary>
            <param name="removedItems">Items which were effectively removed from the list.</param>
            <returns>Number of items which were effectively removed from the list.</returns>
        </member>
        <member name="T:Uno.Validation.ValidationHelper">
            <summary>
            Static class containing a series of method for validating inputs
            </summary>
        </member>
        <member name="F:Uno.Validation.ValidationHelper._acceptedCharsInUSAndCanadianPhones">
            <summary>
            The accepted chars used to validate the US and Canadian phones
            </summary>
        </member>
        <member name="F:Uno.Validation.ValidationHelper._regexOptions">
            <summary>
            The regex options
            </summary>
        </member>
        <member name="F:Uno.Validation.ValidationHelper.EmailRegex">
            <summary>
            The email regex.
            </summary>
            <remarks>
            Accepts any email address adhering to the w3c standard that does NOT contain non-latin characters.
            </remarks>
        </member>
        <member name="F:Uno.Validation.ValidationHelper.CanadianPostalCodeRegex">
            <summary>
            The Canadian postal code regex. can be lower case with no space.
            </summary>
        </member>
        <member name="F:Uno.Validation.ValidationHelper.ZipCodeRegex">
            <summary>
            The zip code regex, valid input can be in the form ddddd or ddddd-dddd
            </summary>
        </member>
        <member name="F:Uno.Validation.ValidationHelper.USStateOnlyRegex">
            <summary>
            Gets the us state only regex. Does not include the Territories and Military symbols
            </summary>
            <value>
            The us state only regex.
            </value>
        </member>
        <member name="F:Uno.Validation.ValidationHelper.USStateWithTerritoriesAndMillitaryRegex">
            <summary>
            Gets the us state regex. Includes the Territories and Military symbols
            </summary>
            <value>
            The us state only regex.
            </value>
        </member>
        <member name="F:Uno.Validation.ValidationHelper.USStateWithTerritoriesRegex">
            <summary>
            Gets the us state regex. Includes the Territories but not and Military symbols
            </summary>
            <value>
            The us state only regex.
            </value>
        </member>
        <member name="F:Uno.Validation.ValidationHelper.USStateWithMillitaryRegex">
            <summary>
            Gets the us state regex. Includes the Military but not and Territories symbols
            </summary>
            <value>
            The us state only regex.
            </value>
        </member>
        <member name="M:Uno.Validation.ValidationHelper.IsEmail(System.String)">
            <summary>
            Determines whether the specified input is a valid email.
            The minimum format of the email must be x@x.xx
            </summary>
            <remarks>Regex currently limited to ASCII characters.</remarks>
            <param name="input">The input. If <c>null</c> returns <c>false</c>.</param>
            <returns>
              <c>true</c> if the specified input is a valid email; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Uno.Validation.ValidationHelper.IsCanadianPostalCode(System.String)">
            <summary>
            Determines whether the specified input is a valid Canadian postal code.
            </summary>
            <param name="input">The input. If <c>null</c> returns <c>false</c>.</param>
            <returns>
              <c>true</c> if the specified input is a valid Canadian postal code; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Uno.Validation.ValidationHelper.IsZipCode(System.String)">
            <summary>
            Determines whether the specified input is a valid US zip code.
            Valid input can be 5 digits or 5 digits followed by 4 digits in the form of ddddd-dddd
            </summary>
            <param name="input">The input. If <c>null</c> returns <c>false</c>.</param>
            <returns>
              <c>true</c> if the specified input is a valid US zip code; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Uno.Validation.ValidationHelper.IsUSState(System.String,System.Boolean,System.Boolean)">
            <summary>
            Validates US States and/or Territories by @jdforsythe
            Case insensitive
            Can include US Territories or not - default does not 
            Can include US Military postal abbreviations(AA, AE, AP) - default does not
            Note: "States" always includes DC(District of Colombia)
            https://en.wikipedia.org/wiki/List_of_U.S._state_abbreviations
            </summary>
            <param name="input">The input. If <c>null</c> returns <c>false</c>.</param>
            <param name="includeTerritories"></param>
            <param name="includeMilitary"></param>
            <returns></returns>
        </member>
        <member name="M:Uno.Validation.ValidationHelper.IsCurrency(System.String,System.IFormatProvider)">
            <summary>
            Determines whether the specified input is valid currency.
            </summary>
            <param name="input">The input. If <c>null</c> returns <c>false</c>.</param>
            <param name="symbol">The symbol.</param>
            <param name="optinalSymbol">if set to <c>true</c> the symbol is optional to be considered valid.</param>
            <returns>
              <c>true</c> if the specified input is valid currency; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Uno.Validation.ValidationHelper.IsUSCanadaPhone(System.String)">
            <summary>
            Determines whether the specified input is a valid north American phone number.
            To be valid it as to have 7 or 10 digits anything else in between is not validated i.e. separators
            </summary>
            <param name="input">The input. If <c>null</c> returns <c>false</c>.</param>
            <returns>
              <c>true</c> if the specified input is a valid north American phone; otherwise, <c>false</c>.
            </returns>
        </member>
    </members>
</doc>
